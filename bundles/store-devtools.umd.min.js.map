{"version":3,"sources":["../../../modules/store-devtools/src/utils.ts","../../../modules/store-devtools/src/reducer.ts","../../../modules/store-devtools/src/instrument.ts","../../../modules/store-devtools/src/config.ts","../../../modules/store-devtools/src/actions.ts","../../../modules/store-devtools/src/extension.ts","../../../modules/store-devtools/src/devtools.ts"],"names":["difference","first","second","filter","item","indexOf","unliftState","liftedState","computedStates","currentStateIndex","state","liftAction","action","Actions.PerformAction","applyOperators","input$","operators","reduce","source$","_a","operator","args","slice","apply","computeNextEntry","reducer","error","nextError","nextState","err","toString","console","stack","recomputeStates","minInvalidatedStateIndex","committedState","actionsById","stagedActionIds","skippedActionIds","length","nextComputedStates","i","actionId","previousEntry","previousState","previousError","undefined","shouldSkip","entry","push","liftInitialState","initialCommittedState","monitorReducer","monitorState","nextActionId","0","INIT_ACTION","liftReducerWith","initialLiftedState","options","liftedAction","commitExcessActions","n","excess","idsToDelete","id","concat","Object","create","type","Actions.RESET","Actions.COMMIT","Actions.ROLLBACK","Actions.TOGGLE_ACTION","actionId_1","index","Actions.SET_ACTIONS_ACTIVE","start","end","active","actionIds","Actions.JUMP_TO_STATE","Infinity","Actions.SWEEP","Math","min","Actions.PERFORM_ACTION","maxAge","Actions.IMPORT_STATE","_b","nextLiftedState","UPDATE","INIT","createIsExtensionOrMonitorPresent","extension","config","Boolean","monitor","noMonitor","createReduxDevtoolsExtension","window","createStateObservable","devtools","noActionSanitizer","noStateSanitizer","createConfig","_options","DEFAULT_OPTIONS","actionSanitizer","stateSanitizer","name","DEFAULT_NAME","serialize","assign","Error","StoreDevtoolsConfig","STORE_DEVTOOLS_CONFIG","InjectionToken","INITIAL_OPTIONS","PERFORM_ACTION","RESET","ROLLBACK","COMMIT","SWEEP","TOGGLE_ACTION","SET_ACTIONS_ACTIVE","JUMP_TO_STATE","IMPORT_STATE","PerformAction","timestamp","this","Reset","Rollback","Commit","Sweep","ToggleAction","JumpToState","ImportState","ExtensionActionTypes","START","DISPATCH","STOP","ACTION","REDUX_DEVTOOLS_EXTENSION","DevtoolsExtension","devtoolsExtension","instanceId","Date","now","createActionStreams","prototype","notify","send","createChangesObservable","_this","Observable","subscriber","connection","connect","subscribe","change","next","unsubscribe","empty","changes$","share","call","start$","stop$","liftedActions$","map","unwrapAction","payload","actions$","actionsUntilStop$","takeUntil","liftedUntilStop$","switchMap","eval","decorators","Injectable","ctorParameters","Inject","DevtoolsDispatcher","_super","__extends","ActionsSubject","StoreDevtools","dispatcher","reducers$","scannedActions","initialState","liftedInitialState","liftReducer","liftedAction$","asObservable","skip","merge","observeOn","queue","liftedReducer$","liftedStateSubject","ReplaySubject","liftedStateSubscription","withLatestFrom","scan","unliftedAction","liftedState$","state$","stateSubscription","dispatch","complete","performAction","reset","Actions.Reset","rollback","Actions.Rollback","commit","Actions.Commit","sweep","Actions.Sweep","toggleAction","Actions.ToggleAction","jumpToState","Actions.JumpToState","importState","Actions.ImportState","ReducerObservable","ScannedActionsSubject","INITIAL_STATE","IS_EXTENSION_OR_MONITOR_PRESENT","StoreDevtoolsModule","instrument","ngModule","providers","provide","useValue","deps","useFactory","StateObservable","ReducerManagerDispatcher","useExisting","NgModule"],"mappings":"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","file":"./dist/store-devtools/bundles/store-devtools.umd.min.js","sourcesContent":["import { Action } from '@ngrx/store';\nimport { Observable } from 'rxjs/Observable';\nimport { LiftedState } from './reducer';\nimport * as Actions from './actions';\n/**\n * @param {?} first\n * @param {?} second\n * @return {?}\n */\nexport function difference(first: any[], second: any[]) {\n  return first.filter(item => second.indexOf(item) < 0);\n}\n/**\n * Provides an app's view into the state of the lifted store.\n * @param {?} liftedState\n * @return {?}\n */\nexport function unliftState(liftedState: LiftedState) {\n  const { computedStates, currentStateIndex } = liftedState;\n  const { state } = computedStates[currentStateIndex];\n\n  return state;\n}\n/**\n * @param {?} liftedState\n * @return {?}\n */\nexport function unliftAction(liftedState: LiftedState) {\n  return liftedState.actionsById[liftedState.nextActionId - 1];\n}\n/**\n * Lifts an app's action into an action on the lifted store.\n * @param {?} action\n * @return {?}\n */\nexport function liftAction(action: Action) {\n  return new Actions.PerformAction(action);\n}\n/**\n * @param {?} input$\n * @param {?} operators\n * @return {?}\n */\nexport function applyOperators(\n  input$: Observable<any>,\n  operators: any[][]\n): Observable<any> {\n  return operators.reduce((source$, [operator, ...args]) => {\n    return operator.apply(source$, args);\n  }, input$);\n}\n","import {\n  Action,\n  ActionReducer,\n  ActionsSubject,\n  ReducerManager,\n  UPDATE,\n  INIT,\n} from '@ngrx/store';\nimport { difference, liftAction } from './utils';\nimport * as Actions from './actions';\nimport { StoreDevtoolsConfig } from './config';\n\nexport type InitAction = {\n  readonly type: typeof INIT;\n};\n\nexport type UpdateReducerAction = {\n  readonly type: typeof UPDATE;\n};\n\nexport type CoreActions = InitAction | UpdateReducerAction;\nexport type Actions = Actions.All | CoreActions;\n\nexport const /** @type {?} */ INIT_ACTION = { type: INIT };\n\nexport interface LiftedState {\n  monitorState: any;\n  nextActionId: number;\n  actionsById: { [id: number]: { action: Action } };\n  stagedActionIds: number[];\n  skippedActionIds: number[];\n  committedState: any;\n  currentStateIndex: number;\n  computedStates: { state: any; error: any }[];\n}\n/**\n * Computes the next entry in the log by applying an action.\n * @param {?} reducer\n * @param {?} action\n * @param {?} state\n * @param {?} error\n * @return {?}\n */\nfunction computeNextEntry(\n  reducer: ActionReducer<any, any>,\n  action: Action,\n  state: LiftedState,\n  error: any\n) {\n  if (error) {\n    return {\n      state,\n      error: 'Interrupted by an error up the chain',\n    };\n  }\n\n  let /** @type {?} */ nextState = state;\n  let /** @type {?} */ nextError;\n  try {\n    nextState = reducer(state, action);\n  } catch ( /** @type {?} */err) {\n    nextError = err.toString();\n    console.error(err.stack || err);\n  }\n\n  return {\n    state: nextState,\n    error: nextError,\n  };\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n * @param {?} computedStates\n * @param {?} minInvalidatedStateIndex\n * @param {?} reducer\n * @param {?} committedState\n * @param {?} actionsById\n * @param {?} stagedActionIds\n * @param {?} skippedActionIds\n * @return {?}\n */\nfunction recomputeStates(\n  computedStates: { state: any; error: any }[],\n  minInvalidatedStateIndex: number,\n  reducer: ActionReducer<any, any>,\n  committedState: any,\n  actionsById: { [id: number]: { action: Action } },\n  stagedActionIds: number[],\n  skippedActionIds: number[]\n) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (\n    minInvalidatedStateIndex >= computedStates.length &&\n    computedStates.length === stagedActionIds.length\n  ) {\n    return computedStates;\n  }\n\n  const /** @type {?} */ nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n  for (let /** @type {?} */ i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {\n    const /** @type {?} */ actionId = stagedActionIds[i];\n    const /** @type {?} */ action = actionsById[actionId].action;\n\n    const /** @type {?} */ previousEntry = nextComputedStates[i - 1];\n    const /** @type {?} */ previousState = previousEntry ? previousEntry.state : committedState;\n    const /** @type {?} */ previousError = previousEntry ? previousEntry.error : undefined;\n\n    const /** @type {?} */ shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    const /** @type {?} */ entry = shouldSkip\n      ? previousEntry\n      : computeNextEntry(reducer, action, previousState, previousError);\n\n    nextComputedStates.push(entry);\n  }\n\n  return nextComputedStates;\n}\n/**\n * @param {?=} initialCommittedState\n * @param {?=} monitorReducer\n * @return {?}\n */\nexport function liftInitialState(\n  initialCommittedState?: any,\n  monitorReducer?: any\n): LiftedState {\n  return {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: { 0: liftAction(INIT_ACTION) },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n  };\n}\n/**\n * Creates a history state reducer from an app's reducer.\n * @param {?} initialCommittedState\n * @param {?} initialLiftedState\n * @param {?=} monitorReducer\n * @param {?=} options\n * @return {?}\n */\nexport function liftReducerWith(\n  initialCommittedState: any,\n  initialLiftedState: LiftedState,\n  monitorReducer?: any,\n  options: Partial<StoreDevtoolsConfig> = {}\n) {\n  /**\n  * Manages how the history actions modify the history state.\n  */\n  return (\n    reducer: ActionReducer<any, any>\n  ): ActionReducer<LiftedState, Actions> => (liftedState, liftedAction) => {\n    let {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n    } =\n      liftedState || initialLiftedState;\n\n    if (!liftedState) {\n      // Prevent mutating initialLiftedState\n      actionsById = Object.create(actionsById);\n    }\n/**\n * @param {?} n\n * @return {?}\n */\nfunction commitExcessActions(n: number) {\n      // Auto-commits n-number of excess actions.\n      let /** @type {?} */ excess = n;\n      let /** @type {?} */ idsToDelete = stagedActionIds.slice(1, excess + 1);\n\n      for (let /** @type {?} */ i = 0; i < idsToDelete.length; i++) {\n        if (computedStates[i + 1].error) {\n          // Stop if error is found. Commit actions up to error.\n          excess = i;\n          idsToDelete = stagedActionIds.slice(1, excess + 1);\n          break;\n        } else {\n          delete actionsById[idsToDelete[i]];\n        }\n      }\n\n      skippedActionIds = skippedActionIds.filter(\n        id => idsToDelete.indexOf(id) === -1\n      );\n      stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];\n      committedState = computedStates[excess].state;\n      computedStates = computedStates.slice(excess);\n      currentStateIndex =\n        currentStateIndex > excess ? currentStateIndex - excess : 0;\n    }\n\n    // By default, agressively recompute every state whatever happens.\n    // This has O(n) performance, so we'll override this to a sensible\n    // value whenever we feel like we don't have to recompute the states.\n    let /** @type {?} */ minInvalidatedStateIndex = 0;\n\n    switch (liftedAction.type) {\n      case Actions.RESET: {\n        // Get back to the state the store was created with.\n        actionsById = { 0: liftAction(INIT_ACTION) };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = initialCommittedState;\n        currentStateIndex = 0;\n        computedStates = [];\n        break;\n      }\n      case Actions.COMMIT: {\n        // Consider the last committed state the new starting point.\n        // Squash any staged actions into a single committed state.\n        actionsById = { 0: liftAction(INIT_ACTION) };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = computedStates[currentStateIndex].state;\n        currentStateIndex = 0;\n        computedStates = [];\n        break;\n      }\n      case Actions.ROLLBACK: {\n        // Forget about any staged actions.\n        // Start again from the last committed state.\n        actionsById = { 0: liftAction(INIT_ACTION) };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        currentStateIndex = 0;\n        computedStates = [];\n        break;\n      }\n      case Actions.TOGGLE_ACTION: {\n        // Toggle whether an action with given ID is skipped.\n        // Being skipped means it is a no-op during the computation.\n        const { id: actionId } = liftedAction;\n        const /** @type {?} */ index = skippedActionIds.indexOf(actionId);\n        if (index === -1) {\n          skippedActionIds = [actionId, ...skippedActionIds];\n        } else {\n          skippedActionIds = skippedActionIds.filter(id => id !== actionId);\n        }\n        // Optimization: we know history before this action hasn't changed\n        minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n        break;\n      }\n      case Actions.SET_ACTIONS_ACTIVE: {\n        // Toggle whether an action with given ID is skipped.\n        // Being skipped means it is a no-op during the computation.\n        const { start, end, active } = liftedAction;\n        const /** @type {?} */ actionIds = [];\n        for (let /** @type {?} */ i = start; i < end; i++) actionIds.push(i);\n        if (active) {\n          skippedActionIds = difference(skippedActionIds, actionIds);\n        } else {\n          skippedActionIds = [...skippedActionIds, ...actionIds];\n        }\n\n        // Optimization: we know history before this action hasn't changed\n        minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n        break;\n      }\n      case Actions.JUMP_TO_STATE: {\n        // Without recomputing anything, move the pointer that tell us\n        // which state is considered the current one. Useful for sliders.\n        currentStateIndex = liftedAction.index;\n        // Optimization: we know the history has not changed.\n        minInvalidatedStateIndex = Infinity;\n        break;\n      }\n      case Actions.SWEEP: {\n        // Forget any actions that are currently being skipped.\n        stagedActionIds = difference(stagedActionIds, skippedActionIds);\n        skippedActionIds = [];\n        currentStateIndex = Math.min(\n          currentStateIndex,\n          stagedActionIds.length - 1\n        );\n        break;\n      }\n      case Actions.PERFORM_ACTION: {\n        // Auto-commit as new actions come in.\n        if (options.maxAge && stagedActionIds.length === options.maxAge) {\n          commitExcessActions(1);\n        }\n\n        if (currentStateIndex === stagedActionIds.length - 1) {\n          currentStateIndex++;\n        }\n        const /** @type {?} */ actionId = nextActionId++;\n        // Mutation! This is the hottest path, and we optimize on purpose.\n        // It is safe because we set a new key in a cache dictionary.\n        actionsById[actionId] = liftedAction;\n        stagedActionIds = [...stagedActionIds, actionId];\n        // Optimization: we know that only the new action needs computing.\n        minInvalidatedStateIndex = stagedActionIds.length - 1;\n        break;\n      }\n      case Actions.IMPORT_STATE: {\n        // Completely replace everything.\n        ({\n          monitorState,\n          actionsById,\n          nextActionId,\n          stagedActionIds,\n          skippedActionIds,\n          committedState,\n          currentStateIndex,\n          computedStates,\n        } = liftedAction.nextLiftedState);\n        break;\n      }\n      case UPDATE:\n      case INIT: {\n        // Always recompute states on hot reload and init.\n        minInvalidatedStateIndex = 0;\n\n        if (options.maxAge && stagedActionIds.length > options.maxAge) {\n          // States must be recomputed before committing excess.\n          computedStates = recomputeStates(\n            computedStates,\n            minInvalidatedStateIndex,\n            reducer,\n            committedState,\n            actionsById,\n            stagedActionIds,\n            skippedActionIds\n          );\n\n          commitExcessActions(stagedActionIds.length - options.maxAge);\n\n          // Avoid double computation.\n          minInvalidatedStateIndex = Infinity;\n        }\n\n        break;\n      }\n      default: {\n        // If the action is not recognized, it's a monitor action.\n        // Optimization: a monitor action can't change history.\n        minInvalidatedStateIndex = Infinity;\n        break;\n      }\n    }\n\n    computedStates = recomputeStates(\n      computedStates,\n      minInvalidatedStateIndex,\n      reducer,\n      committedState,\n      actionsById,\n      stagedActionIds,\n      skippedActionIds\n    );\n    monitorState = monitorReducer(monitorState, liftedAction);\n\n    return {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n    };\n  };\n}\n","import {\n  NgModule,\n  InjectionToken,\n  Injector,\n  ModuleWithProviders,\n} from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\nimport {\n  StoreModule,\n  State,\n  StateObservable,\n  ActionsSubject,\n  ScannedActionsSubject,\n  ReducerObservable,\n  ReducerManagerDispatcher,\n  ActionReducerMap,\n  ActionReducerFactory,\n  INITIAL_STATE,\n  INITIAL_REDUCERS,\n  REDUCER_FACTORY,\n} from '@ngrx/store';\nimport { StoreDevtools, DevtoolsDispatcher } from './devtools';\nimport {\n  StoreDevtoolsConfig,\n  StoreDevtoolsOptions,\n  STORE_DEVTOOLS_CONFIG,\n  INITIAL_OPTIONS,\n} from './config';\nimport {\n  DevtoolsExtension,\n  REDUX_DEVTOOLS_EXTENSION,\n  ReduxDevtoolsExtension,\n} from './extension';\n\nexport const /** @type {?} */ IS_EXTENSION_OR_MONITOR_PRESENT = new InjectionToken<boolean>(\n  'Is Devtools Extension or Monitor Present'\n);\n/**\n * @param {?} extension\n * @param {?} config\n * @return {?}\n */\nexport function createIsExtensionOrMonitorPresent(\n  extension: ReduxDevtoolsExtension | null,\n  config: StoreDevtoolsConfig\n) {\n  return Boolean(extension) || config.monitor !== noMonitor;\n}\n/**\n * @return {?}\n */\nexport function createReduxDevtoolsExtension() {\n  const /** @type {?} */ extensionKey = '__REDUX_DEVTOOLS_EXTENSION__';\n\n  if (\n    typeof window === 'object' &&\n    typeof ( /** @type {?} */((window as any)))[extensionKey] !== 'undefined'\n  ) {\n    return ( /** @type {?} */((window as any)))[extensionKey];\n  } else {\n    return null;\n  }\n}\n/**\n * @param {?} devtools\n * @return {?}\n */\nexport function createStateObservable(devtools: StoreDevtools) {\n  return devtools.state;\n}\n/**\n * @return {?}\n */\nexport function noMonitor(): null {\n  return null;\n}\n/**\n * @return {?}\n */\nexport function noActionSanitizer(): null {\n  return null;\n}\n/**\n * @return {?}\n */\nexport function noStateSanitizer(): null {\n  return null;\n}\n\nexport const /** @type {?} */ DEFAULT_NAME = 'NgRx Store DevTools';\n/**\n * @param {?} _options\n * @return {?}\n */\nexport function createConfig(\n  _options: StoreDevtoolsOptions\n): StoreDevtoolsConfig {\n  const /** @type {?} */ DEFAULT_OPTIONS: StoreDevtoolsConfig = {\n    maxAge: false,\n    monitor: noMonitor,\n    actionSanitizer: noActionSanitizer,\n    stateSanitizer: noStateSanitizer,\n    name: DEFAULT_NAME,\n    serialize: false,\n  };\n\n  let /** @type {?} */ options = typeof _options === 'function' ? _options() : _options;\n  const /** @type {?} */ config = Object.assign({}, DEFAULT_OPTIONS, options);\n\n  if (config.maxAge && config.maxAge < 2) {\n    throw new Error(\n      `Devtools 'maxAge' cannot be less than 2, got ${config.maxAge}`\n    );\n  }\n\n  return config;\n}\nexport class StoreDevtoolsModule {\n/**\n * @param {?=} options\n * @return {?}\n */\nstatic instrument(options: StoreDevtoolsOptions = {}): ModuleWithProviders {\n    return {\n      ngModule: StoreDevtoolsModule,\n      providers: [\n        DevtoolsExtension,\n        DevtoolsDispatcher,\n        StoreDevtools,\n        {\n          provide: INITIAL_OPTIONS,\n          useValue: options,\n        },\n        {\n          provide: IS_EXTENSION_OR_MONITOR_PRESENT,\n          deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],\n          useFactory: createIsExtensionOrMonitorPresent,\n        },\n        {\n          provide: REDUX_DEVTOOLS_EXTENSION,\n          useFactory: createReduxDevtoolsExtension,\n        },\n        {\n          provide: STORE_DEVTOOLS_CONFIG,\n          deps: [INITIAL_OPTIONS],\n          useFactory: createConfig,\n        },\n        {\n          provide: StateObservable,\n          deps: [StoreDevtools],\n          useFactory: createStateObservable,\n        },\n        {\n          provide: ReducerManagerDispatcher,\n          useExisting: DevtoolsDispatcher,\n        },\n      ],\n    };\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction StoreDevtoolsModule_tsickle_Closure_declarations() {\n/** @type {?} */\nStoreDevtoolsModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nStoreDevtoolsModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { ActionReducer, Action } from '@ngrx/store';\nimport { InjectionToken, Type } from '@angular/core';\nexport class StoreDevtoolsConfig {\n  maxAge: number | false;\n  monitor: ActionReducer<any, any>;\n  actionSanitizer?: <A extends Action>(action: A, id: number) => A;\n  stateSanitizer?: <S>(state: S, index: number) => S;\n  name?: string;\n  serialize?: boolean;\n}\n\nfunction StoreDevtoolsConfig_tsickle_Closure_declarations() {\n/** @type {?} */\nStoreDevtoolsConfig.prototype.maxAge;\n/** @type {?} */\nStoreDevtoolsConfig.prototype.monitor;\n/** @type {?} */\nStoreDevtoolsConfig.prototype.actionSanitizer;\n/** @type {?} */\nStoreDevtoolsConfig.prototype.stateSanitizer;\n/** @type {?} */\nStoreDevtoolsConfig.prototype.name;\n/** @type {?} */\nStoreDevtoolsConfig.prototype.serialize;\n}\n\n\nexport const /** @type {?} */ STORE_DEVTOOLS_CONFIG = new InjectionToken<StoreDevtoolsConfig>(\n  '@ngrx/devtools Options'\n);\nexport const /** @type {?} */ INITIAL_OPTIONS = new InjectionToken<StoreDevtoolsConfig>(\n  '@ngrx/devtools Initial Config'\n);\n\nexport type StoreDevtoolsOptions =\n  | Partial<StoreDevtoolsConfig>\n  | (() => Partial<StoreDevtoolsConfig>);\n","import { Action } from '@ngrx/store';\n\nexport const /** @type {?} */ PERFORM_ACTION = 'PERFORM_ACTION';\nexport const /** @type {?} */ RESET = 'RESET';\nexport const /** @type {?} */ ROLLBACK = 'ROLLBACK';\nexport const /** @type {?} */ COMMIT = 'COMMIT';\nexport const /** @type {?} */ SWEEP = 'SWEEP';\nexport const /** @type {?} */ TOGGLE_ACTION = 'TOGGLE_ACTION';\nexport const /** @type {?} */ SET_ACTIONS_ACTIVE = 'SET_ACTIONS_ACTIVE';\nexport const /** @type {?} */ JUMP_TO_STATE = 'JUMP_TO_STATE';\nexport const /** @type {?} */ IMPORT_STATE = 'IMPORT_STATE';\nexport class PerformAction implements Action {\n  readonly type = PERFORM_ACTION;\n/**\n * @param {?} action\n * @param {?=} timestamp\n */\nconstructor(public action: Action,\npublic timestamp?: number) {\n    if (typeof action.type === 'undefined') {\n      throw new Error(\n        'Actions may not have an undefined \"type\" property. ' +\n          'Have you misspelled a constant?'\n      );\n    }\n  }\n}\n\nfunction PerformAction_tsickle_Closure_declarations() {\n/** @type {?} */\nPerformAction.prototype.type;\n/** @type {?} */\nPerformAction.prototype.action;\n/** @type {?} */\nPerformAction.prototype.timestamp;\n}\n\nexport class Reset implements Action {\n  readonly type = RESET;\n/**\n * @param {?=} timestamp\n */\nconstructor(public timestamp?: number) {}\n}\n\nfunction Reset_tsickle_Closure_declarations() {\n/** @type {?} */\nReset.prototype.type;\n/** @type {?} */\nReset.prototype.timestamp;\n}\n\nexport class Rollback implements Action {\n  readonly type = ROLLBACK;\n/**\n * @param {?=} timestamp\n */\nconstructor(public timestamp?: number) {}\n}\n\nfunction Rollback_tsickle_Closure_declarations() {\n/** @type {?} */\nRollback.prototype.type;\n/** @type {?} */\nRollback.prototype.timestamp;\n}\n\nexport class Commit implements Action {\n  readonly type = COMMIT;\n/**\n * @param {?=} timestamp\n */\nconstructor(public timestamp?: number) {}\n}\n\nfunction Commit_tsickle_Closure_declarations() {\n/** @type {?} */\nCommit.prototype.type;\n/** @type {?} */\nCommit.prototype.timestamp;\n}\n\nexport class Sweep implements Action {\n  readonly type = SWEEP;\n}\n\nfunction Sweep_tsickle_Closure_declarations() {\n/** @type {?} */\nSweep.prototype.type;\n}\n\nexport class ToggleAction implements Action {\n  readonly type = TOGGLE_ACTION;\n/**\n * @param {?} id\n */\nconstructor(public id: number) {}\n}\n\nfunction ToggleAction_tsickle_Closure_declarations() {\n/** @type {?} */\nToggleAction.prototype.type;\n/** @type {?} */\nToggleAction.prototype.id;\n}\n\nexport class SetActionsActive implements Action {\n  readonly type = SET_ACTIONS_ACTIVE;\n/**\n * @param {?} start\n * @param {?} end\n * @param {?=} active\n */\nconstructor(\npublic start: number,\npublic end: number,\npublic active: boolean = true\n  ) {}\n}\n\nfunction SetActionsActive_tsickle_Closure_declarations() {\n/** @type {?} */\nSetActionsActive.prototype.type;\n/** @type {?} */\nSetActionsActive.prototype.start;\n/** @type {?} */\nSetActionsActive.prototype.end;\n/** @type {?} */\nSetActionsActive.prototype.active;\n}\n\nexport class JumpToState implements Action {\n  readonly type = JUMP_TO_STATE;\n/**\n * @param {?} index\n */\nconstructor(public index: number) {}\n}\n\nfunction JumpToState_tsickle_Closure_declarations() {\n/** @type {?} */\nJumpToState.prototype.type;\n/** @type {?} */\nJumpToState.prototype.index;\n}\n\nexport class ImportState implements Action {\n  readonly type = IMPORT_STATE;\n/**\n * @param {?} nextLiftedState\n */\nconstructor(public nextLiftedState: any) {}\n}\n\nfunction ImportState_tsickle_Closure_declarations() {\n/** @type {?} */\nImportState.prototype.type;\n/** @type {?} */\nImportState.prototype.nextLiftedState;\n}\n\n\nexport type All =\n  | PerformAction\n  | Reset\n  | Rollback\n  | Commit\n  | Sweep\n  | ToggleAction\n  | SetActionsActive\n  | JumpToState\n  | ImportState;\n","import { Inject, Injectable, InjectionToken } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { Observable } from 'rxjs/Observable';\nimport { empty } from 'rxjs/observable/empty';\nimport { filter } from 'rxjs/operator/filter';\nimport { map } from 'rxjs/operator/map';\nimport { share } from 'rxjs/operator/share';\nimport { switchMap } from 'rxjs/operator/switchMap';\nimport { takeUntil } from 'rxjs/operator/takeUntil';\n\nimport { STORE_DEVTOOLS_CONFIG, StoreDevtoolsConfig } from './config';\nimport { LiftedState } from './reducer';\nimport { applyOperators } from './utils';\n\nexport const /** @type {?} */ ExtensionActionTypes = {\n  START: 'START',\n  DISPATCH: 'DISPATCH',\n  STOP: 'STOP',\n  ACTION: 'ACTION',\n};\n\nexport const /** @type {?} */ REDUX_DEVTOOLS_EXTENSION = new InjectionToken<\n  ReduxDevtoolsExtension\n>('Redux Devtools Extension');\n\nexport interface ReduxDevtoolsExtensionConnection {\n  subscribe(listener: (change: any) => void): void;\n  unsubscribe(): void;\n  send(action: any, state: any): void;\n}\n\nexport interface ReduxDevtoolsExtension {\n  connect(options: {\n    shouldStringify?: boolean;\n    instanceId: string;\n  }): ReduxDevtoolsExtensionConnection;\n  send(\n    action: any,\n    state: any,\n    options: StoreDevtoolsConfig,\n    instanceId?: string\n  ): void;\n}\nexport class DevtoolsExtension {\nprivate instanceId = `ngrx-store-${Date.now()}`;\nprivate devtoolsExtension: ReduxDevtoolsExtension;\n\n  liftedActions$: Observable<any>;\n  actions$: Observable<any>;\n/**\n * @param {?} devtoolsExtension\n * @param {?} config\n */\nconstructor(\n     devtoolsExtension: ReduxDevtoolsExtension,\nprivate config: StoreDevtoolsConfig\n  ) {\n    this.devtoolsExtension = devtoolsExtension;\n    this.createActionStreams();\n  }\n/**\n * @param {?} action\n * @param {?} state\n * @return {?}\n */\nnotify(action: Action, state: LiftedState) {\n    if (!this.devtoolsExtension) {\n      return;\n    }\n\n    this.devtoolsExtension.send(null, state, this.config, this.instanceId);\n  }\n/**\n * @return {?}\n */\nprivate createChangesObservable(): Observable<any> {\n    if (!this.devtoolsExtension) {\n      return empty();\n    }\n\n    return new Observable(subscriber => {\n      const /** @type {?} */ connection = this.devtoolsExtension.connect({\n        instanceId: this.instanceId,\n      });\n\n      connection.subscribe((change: any) => subscriber.next(change));\n\n      return connection.unsubscribe;\n    });\n  }\n/**\n * @return {?}\n */\nprivate createActionStreams() {\n    // Listens to all changes based on our instanceId\n    const /** @type {?} */ changes$ = share.call(this.createChangesObservable());\n\n    // Listen for the start action\n    const /** @type {?} */ start$ = filter.call(\n      changes$,\n      (change: any) => change.type === ExtensionActionTypes.START\n    );\n\n    // Listen for the stop action\n    const /** @type {?} */ stop$ = filter.call(\n      changes$,\n      (change: any) => change.type === ExtensionActionTypes.STOP\n    );\n\n    // Listen for lifted actions\n    const /** @type {?} */ liftedActions$ = applyOperators(changes$, [\n      [filter, (change: any) => change.type === ExtensionActionTypes.DISPATCH],\n      [map, (change: any) => this.unwrapAction(change.payload)],\n    ]);\n\n    // Listen for unlifted actions\n    const /** @type {?} */ actions$ = applyOperators(changes$, [\n      [filter, (change: any) => change.type === ExtensionActionTypes.ACTION],\n      [map, (change: any) => this.unwrapAction(change.payload)],\n    ]);\n\n    const /** @type {?} */ actionsUntilStop$ = takeUntil.call(actions$, stop$);\n    const /** @type {?} */ liftedUntilStop$ = takeUntil.call(liftedActions$, stop$);\n\n    // Only take the action sources between the start/stop events\n    this.actions$ = switchMap.call(start$, () => actionsUntilStop$);\n    this.liftedActions$ = switchMap.call(start$, () => liftedUntilStop$);\n  }\n/**\n * @param {?} action\n * @return {?}\n */\nprivate unwrapAction(action: Action) {\n    return typeof action === 'string' ? eval(`(${action})`) : action;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: undefined, decorators: [{ type: Inject, args: [REDUX_DEVTOOLS_EXTENSION, ] }, ]},\n{type: StoreDevtoolsConfig, decorators: [{ type: Inject, args: [STORE_DEVTOOLS_CONFIG, ] }, ]},\n];\n}\n\nfunction DevtoolsExtension_tsickle_Closure_declarations() {\n/** @type {?} */\nDevtoolsExtension.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nDevtoolsExtension.ctorParameters;\n/** @type {?} */\nDevtoolsExtension.prototype.instanceId;\n/** @type {?} */\nDevtoolsExtension.prototype.devtoolsExtension;\n/** @type {?} */\nDevtoolsExtension.prototype.liftedActions$;\n/** @type {?} */\nDevtoolsExtension.prototype.actions$;\n/** @type {?} */\nDevtoolsExtension.prototype.config;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Injectable, Inject, OnDestroy } from '@angular/core';\nimport {\n  State,\n  Action,\n  INITIAL_STATE,\n  ReducerObservable,\n  ActionsSubject,\n  ScannedActionsSubject,\n} from '@ngrx/store';\nimport { Observable } from 'rxjs/Observable';\nimport { ReplaySubject } from 'rxjs/ReplaySubject';\nimport { Observer } from 'rxjs/Observer';\nimport { Subscription } from 'rxjs/Subscription';\nimport { map } from 'rxjs/operator/map';\nimport { merge } from 'rxjs/operator/merge';\nimport { observeOn } from 'rxjs/operator/observeOn';\nimport { scan } from 'rxjs/operator/scan';\nimport { skip } from 'rxjs/operator/skip';\nimport { withLatestFrom } from 'rxjs/operator/withLatestFrom';\nimport { queue } from 'rxjs/scheduler/queue';\n\nimport { DevtoolsExtension } from './extension';\nimport { liftAction, unliftAction, unliftState, applyOperators } from './utils';\nimport { liftReducerWith, liftInitialState, LiftedState } from './reducer';\nimport * as Actions from './actions';\nimport { StoreDevtoolsConfig, STORE_DEVTOOLS_CONFIG } from './config';\nexport class DevtoolsDispatcher extends ActionsSubject {static decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction DevtoolsDispatcher_tsickle_Closure_declarations() {\n/** @type {?} */\nDevtoolsDispatcher.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nDevtoolsDispatcher.ctorParameters;\n}\n\nexport class StoreDevtools implements Observer<any> {\nprivate stateSubscription: Subscription;\npublic dispatcher: ActionsSubject;\npublic liftedState: Observable<LiftedState>;\npublic state: Observable<any>;\n/**\n * @param {?} dispatcher\n * @param {?} actions$\n * @param {?} reducers$\n * @param {?} extension\n * @param {?} scannedActions\n * @param {?} initialState\n * @param {?} config\n */\nconstructor(\n    dispatcher: DevtoolsDispatcher,\n    actions$: ActionsSubject,\n    reducers$: ReducerObservable,\n    extension: DevtoolsExtension,\n    scannedActions: ScannedActionsSubject,\n     initialState: any,\n     config: StoreDevtoolsConfig\n  ) {\n    const liftedInitialState = liftInitialState(initialState, config.monitor);\n    const liftReducer = liftReducerWith(\n      initialState,\n      liftedInitialState,\n      config.monitor,\n      config\n    );\n\n    const liftedAction$ = applyOperators(actions$.asObservable(), [\n      [skip, 1],\n      [merge, extension.actions$],\n      [map, liftAction],\n      [merge, dispatcher, extension.liftedActions$],\n      [observeOn, queue],\n    ]);\n\n    const liftedReducer$ = map.call(reducers$, liftReducer);\n\n    const liftedStateSubject = new ReplaySubject<LiftedState>(1);\n    const liftedStateSubscription = applyOperators(liftedAction$, [\n      [withLatestFrom, liftedReducer$],\n      [\n        scan,\n        ({ state: liftedState }: any, [action, reducer]: any) => {\n          const state = reducer(liftedState, action);\n\n          extension.notify(action, state);\n\n          return { state, action };\n        },\n        { state: liftedInitialState, action: null },\n      ],\n    ]).subscribe(({ state, action }) => {\n      liftedStateSubject.next(state);\n\n      if (action.type === Actions.PERFORM_ACTION) {\n        const unliftedAction = (action as Actions.PerformAction).action;\n\n        scannedActions.next(unliftedAction);\n      }\n    });\n\n    const liftedState$ = liftedStateSubject.asObservable() as Observable<\n      LiftedState\n    >;\n    const state$ = map.call(liftedState$, unliftState);\n\n    this.stateSubscription = liftedStateSubscription;\n    this.dispatcher = dispatcher;\n    this.liftedState = liftedState$;\n    this.state = state$;\n  }\n/**\n * @param {?} action\n * @return {?}\n */\ndispatch(action: Action) {\n    this.dispatcher.next(action);\n  }\n/**\n * @param {?} action\n * @return {?}\n */\nnext(action: any) {\n    this.dispatcher.next(action);\n  }\n/**\n * @param {?} error\n * @return {?}\n */\nerror(error: any) {}\n/**\n * @return {?}\n */\ncomplete() {}\n/**\n * @param {?} action\n * @return {?}\n */\nperformAction(action: any) {\n    this.dispatch(new Actions.PerformAction(action));\n  }\n/**\n * @return {?}\n */\nreset() {\n    this.dispatch(new Actions.Reset());\n  }\n/**\n * @return {?}\n */\nrollback() {\n    this.dispatch(new Actions.Rollback());\n  }\n/**\n * @return {?}\n */\ncommit() {\n    this.dispatch(new Actions.Commit());\n  }\n/**\n * @return {?}\n */\nsweep() {\n    this.dispatch(new Actions.Sweep());\n  }\n/**\n * @param {?} id\n * @return {?}\n */\ntoggleAction(id: number) {\n    this.dispatch(new Actions.ToggleAction(id));\n  }\n/**\n * @param {?} index\n * @return {?}\n */\njumpToState(index: number) {\n    this.dispatch(new Actions.JumpToState(index));\n  }\n/**\n * @param {?} nextLiftedState\n * @return {?}\n */\nimportState(nextLiftedState: any) {\n    this.dispatch(new Actions.ImportState(nextLiftedState));\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: DevtoolsDispatcher, },\n{type: ActionsSubject, },\n{type: ReducerObservable, },\n{type: DevtoolsExtension, },\n{type: ScannedActionsSubject, },\n{type: undefined, decorators: [{ type: Inject, args: [INITIAL_STATE, ] }, ]},\n{type: StoreDevtoolsConfig, decorators: [{ type: Inject, args: [STORE_DEVTOOLS_CONFIG, ] }, ]},\n];\n}\n\nfunction StoreDevtools_tsickle_Closure_declarations() {\n/** @type {?} */\nStoreDevtools.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nStoreDevtools.ctorParameters;\n/** @type {?} */\nStoreDevtools.prototype.stateSubscription;\n/** @type {?} */\nStoreDevtools.prototype.dispatcher;\n/** @type {?} */\nStoreDevtools.prototype.liftedState;\n/** @type {?} */\nStoreDevtools.prototype.state;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}