{"version":3,"sources":["ng://@ngrx/store-devtools/src/config.ts","ng://@ngrx/store-devtools/src/actions.ts","ng://@ngrx/store-devtools/src/devtools-dispatcher.ts","ng://@ngrx/store-devtools/src/utils.ts","ng://@ngrx/store-devtools/src/extension.ts","ng://@ngrx/store-devtools/src/reducer.ts","ng://@ngrx/store-devtools/src/devtools.ts","ng://@ngrx/store-devtools/src/instrument.ts"],"names":["this","maxAge","STORE_DEVTOOLS_CONFIG","InjectionToken","INITIAL_OPTIONS","noMonitor","DEFAULT_NAME","createConfig","_options","DEFAULT_OPTIONS","monitor","actionSanitizer","undefined","stateSanitizer","name","serialize","logOnly","features","pause","lock","persist","export","import","jump","skip","reorder","dispatch","test","options","config","Object","assign","Error","PERFORM_ACTION","REFRESH","RESET","ROLLBACK","COMMIT","SWEEP","TOGGLE_ACTION","SET_ACTIONS_ACTIVE","JUMP_TO_STATE","JUMP_TO_ACTION","IMPORT_STATE","LOCK_CHANGES","PAUSE_RECORDING","PerformAction","action","timestamp","type","Refresh","Reset","Rollback","Commit","Sweep","ToggleAction","id","SetActionsActive","start","end","active","JumpToState","index","JumpToAction","actionId","ImportState","nextLiftedState","LockChanges","status","PauseRecording","DevtoolsDispatcher","__extends","_super","Injectable","ActionsSubject","difference","first","second","filter","item","indexOf","unliftState","liftedState","computedStates","currentStateIndex","length","state","unliftAction","actionsById","nextActionId","liftAction","Actions.PerformAction","Date","now","sanitizeActions","actions","keys","reduce","sanitizedActions","actionIdx","idx","Number","sanitizeAction","__assign","sanitizeStates","states","map","computedState","sanitizeState","error","stateIdx","shouldFilterActions","predicate","actionsSafelist","actionsBlocklist","filterLiftedState","safelist","blocklist","filteredStagedActionIds","filteredActionsById","filteredComputedStates","stagedActionIds","forEach","liftedAction","isActionFiltered","push","blockedlist","predicateMatch","safelistMatch","match","s","escapeRegExp","join","blocklistMatch","replace","ExtensionActionTypes","START","DISPATCH","STOP","ACTION","REDUX_DEVTOOLS_EXTENSION","DevtoolsExtension","devtoolsExtension","dispatcher","createActionStreams","prototype","notify","_this","isLocked","isPaused","currentState","sanitizedState_1","sanitizedAction_1","sendToReduxDevtools","extensionConnection","send","sanitizedLiftedState_1","__assign$1","getExtensionConfig","createChangesObservable","Observable","subscriber","connection","connect","init","subscribe","change","next","unsubscribe","empty","changes$","pipe","share","start$","stop$","liftedActions$","unwrapAction","payload","concatMap","UPDATE","timeout","debounceTime","catchError","of","take","actionsUntilStop$","takeUntil","liftedUntilStop$","actions$","switchMap","eval","extensionOptions","err","console","warn","Inject","args","StoreDevtoolsConfig","decorators","INIT_ACTION","INIT","RECOMPUTE","RECOMPUTE_ACTION","computeNextEntry","reducer","errorHandler","nextError","nextState","toString","handleError","stack","recomputeStates","minInvalidatedStateIndex","committedState","skippedActionIds","nextComputedStates","slice","lastIncludedActionId","i","previousEntry","previousState","previousError","entry","liftInitialState","initialCommittedState","monitorReducer","monitorState","0","liftReducerWith","initialLiftedState","_b","commitExcessActions","n","excess","idsToDelete","__spread","commitChanges","create","DevtoolsActions.LOCK_CHANGES","Infinity","DevtoolsActions.PAUSE_RECORDING","concat","DevtoolsActions.RESET","DevtoolsActions.COMMIT","DevtoolsActions.ROLLBACK","DevtoolsActions.TOGGLE_ACTION","actionId_1","DevtoolsActions.SET_ACTIONS_ACTIVE","actionIds","DevtoolsActions.JUMP_TO_STATE","DevtoolsActions.JUMP_TO_ACTION","DevtoolsActions.SWEEP","Math","min","DevtoolsActions.PERFORM_ACTION","lastState","DevtoolsActions.IMPORT_STATE","_a","cmp","__assign$2","StoreDevtools","reducers$","extension","scannedActions","initialState","liftedInitialState","liftReducer","liftedAction$","merge","asObservable","observeOn","queueScheduler","liftedReducer$","liftedStateSubject","ReplaySubject","liftedStateSubscription","withLatestFrom","scan","_c","__read$1","reducedLiftedState","Actions.PERFORM_ACTION","unliftedAction","extensionStartSubscription","refresh","liftedState$","state$","stateSubscription","complete","performAction","Actions.Refresh","reset","Actions.Reset","rollback","Actions.Rollback","commit","Actions.Commit","sweep","Actions.Sweep","toggleAction","Actions.ToggleAction","jumpToAction","Actions.JumpToAction","jumpToState","Actions.JumpToState","importState","Actions.ImportState","lockChanges","Actions.LockChanges","pauseRecording","Actions.PauseRecording","ReducerObservable","ScannedActionsSubject","ErrorHandler","INITIAL_STATE","IS_EXTENSION_OR_MONITOR_PRESENT","createIsExtensionOrMonitorPresent","Boolean","createReduxDevtoolsExtension","window","createStateObservable","devtools","StoreDevtoolsModule","instrument","ngModule","providers","provide","useValue","deps","useFactory","StateObservable","ReducerManagerDispatcher","useExisting","NgModule"],"mappings":"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","sourcesContent":["import { ActionReducer, Action } from '@ngrx/store';\nimport { InjectionToken } from '@angular/core';\n\nexport type ActionSanitizer = (action: Action, id: number) => Action;\nexport type StateSanitizer = (state: any, index: number) => any;\nexport type SerializationOptions = {\n  options?: boolean | any;\n  replacer?: (key: any, value: any) => {};\n  reviver?: (key: any, value: any) => {};\n  immutable?: any;\n  refs?: Array<any>;\n};\nexport type Predicate = (state: any, action: Action) => boolean;\nexport interface DevToolsFeatureOptions {\n  pause?: boolean;\n  lock?: boolean;\n  persist?: boolean;\n  export?: boolean;\n  import?: 'custom' | boolean;\n  jump?: boolean;\n  skip?: boolean;\n  reorder?: boolean;\n  dispatch?: boolean;\n  test?: boolean;\n}\n\nexport class StoreDevtoolsConfig {\n  maxAge: number | false = false;\n  monitor?: ActionReducer<any, any>;\n  actionSanitizer?: ActionSanitizer;\n  stateSanitizer?: StateSanitizer;\n  name?: string;\n  serialize?: boolean | SerializationOptions;\n  logOnly?: boolean;\n  features?: DevToolsFeatureOptions;\n  actionsBlocklist?: string[];\n  actionsSafelist?: string[];\n  predicate?: Predicate;\n}\n\nexport const STORE_DEVTOOLS_CONFIG = new InjectionToken<StoreDevtoolsConfig>(\n  '@ngrx/devtools Options'\n);\nexport const INITIAL_OPTIONS = new InjectionToken<StoreDevtoolsConfig>(\n  '@ngrx/devtools Initial Config'\n);\n\nexport type StoreDevtoolsOptions =\n  | Partial<StoreDevtoolsConfig>\n  | (() => Partial<StoreDevtoolsConfig>);\n\nexport function noMonitor(): null {\n  return null;\n}\n\nexport const DEFAULT_NAME = 'NgRx Store DevTools';\n\nexport function createConfig(\n  _options: StoreDevtoolsOptions\n): StoreDevtoolsConfig {\n  const DEFAULT_OPTIONS: StoreDevtoolsConfig = {\n    maxAge: false,\n    monitor: noMonitor,\n    actionSanitizer: undefined,\n    stateSanitizer: undefined,\n    name: DEFAULT_NAME,\n    serialize: false,\n    logOnly: false,\n    // Add all features explicitly. This prevent buggy behavior for\n    // options like \"lock\" which might otherwise not show up.\n    features: {\n      pause: true, // start/pause recording of dispatched actions\n      lock: true, // lock/unlock dispatching actions and side effects\n      persist: true, // persist states on page reloading\n      export: true, // export history of actions in a file\n      import: 'custom', // import history of actions from a file\n      jump: true, // jump back and forth (time travelling)\n      skip: true, // skip (cancel) actions\n      reorder: true, // drag and drop actions in the history list\n      dispatch: true, // dispatch custom actions or action creators\n      test: true, // generate tests for the selected actions\n    },\n  };\n\n  let options = typeof _options === 'function' ? _options() : _options;\n  const logOnly = options.logOnly\n    ? { pause: true, export: true, test: true }\n    : false;\n  const features = options.features || logOnly || DEFAULT_OPTIONS.features;\n  const config = Object.assign({}, DEFAULT_OPTIONS, { features }, options);\n\n  if (config.maxAge && config.maxAge < 2) {\n    throw new Error(\n      `Devtools 'maxAge' cannot be less than 2, got ${config.maxAge}`\n    );\n  }\n\n  return config;\n}\n","import { Action } from '@ngrx/store';\n\nexport const PERFORM_ACTION = 'PERFORM_ACTION';\nexport const REFRESH = 'REFRESH';\nexport const RESET = 'RESET';\nexport const ROLLBACK = 'ROLLBACK';\nexport const COMMIT = 'COMMIT';\nexport const SWEEP = 'SWEEP';\nexport const TOGGLE_ACTION = 'TOGGLE_ACTION';\nexport const SET_ACTIONS_ACTIVE = 'SET_ACTIONS_ACTIVE';\nexport const JUMP_TO_STATE = 'JUMP_TO_STATE';\nexport const JUMP_TO_ACTION = 'JUMP_TO_ACTION';\nexport const IMPORT_STATE = 'IMPORT_STATE';\nexport const LOCK_CHANGES = 'LOCK_CHANGES';\nexport const PAUSE_RECORDING = 'PAUSE_RECORDING';\n\nexport class PerformAction implements Action {\n  readonly type = PERFORM_ACTION;\n\n  constructor(public action: Action, public timestamp: number) {\n    if (typeof action.type === 'undefined') {\n      throw new Error(\n        'Actions may not have an undefined \"type\" property. ' +\n          'Have you misspelled a constant?'\n      );\n    }\n  }\n}\n\nexport class Refresh implements Action {\n  readonly type = REFRESH;\n}\n\nexport class Reset implements Action {\n  readonly type = RESET;\n\n  constructor(public timestamp: number) {}\n}\n\nexport class Rollback implements Action {\n  readonly type = ROLLBACK;\n\n  constructor(public timestamp: number) {}\n}\n\nexport class Commit implements Action {\n  readonly type = COMMIT;\n\n  constructor(public timestamp: number) {}\n}\n\nexport class Sweep implements Action {\n  readonly type = SWEEP;\n}\n\nexport class ToggleAction implements Action {\n  readonly type = TOGGLE_ACTION;\n\n  constructor(public id: number) {}\n}\n\nexport class SetActionsActive implements Action {\n  readonly type = SET_ACTIONS_ACTIVE;\n\n  constructor(\n    public start: number,\n    public end: number,\n    public active: boolean = true\n  ) {}\n}\n\nexport class JumpToState implements Action {\n  readonly type = JUMP_TO_STATE;\n\n  constructor(public index: number) {}\n}\n\nexport class JumpToAction implements Action {\n  readonly type = JUMP_TO_ACTION;\n\n  constructor(public actionId: number) {}\n}\n\nexport class ImportState implements Action {\n  readonly type = IMPORT_STATE;\n\n  constructor(public nextLiftedState: any) {}\n}\n\nexport class LockChanges implements Action {\n  readonly type = LOCK_CHANGES;\n\n  constructor(public status: boolean) {}\n}\n\nexport class PauseRecording implements Action {\n  readonly type = PAUSE_RECORDING;\n\n  constructor(public status: boolean) {}\n}\n\nexport type All =\n  | PerformAction\n  | Refresh\n  | Reset\n  | Rollback\n  | Commit\n  | Sweep\n  | ToggleAction\n  | SetActionsActive\n  | JumpToState\n  | JumpToAction\n  | ImportState\n  | LockChanges\n  | PauseRecording;\n","import { ActionsSubject } from '@ngrx/store';\nimport { Injectable } from '@angular/core';\n\n@Injectable()\nexport class DevtoolsDispatcher extends ActionsSubject {}\n","import { Action } from '@ngrx/store';\n\nimport * as Actions from './actions';\nimport {\n  ActionSanitizer,\n  StateSanitizer,\n  Predicate,\n  StoreDevtoolsConfig,\n} from './config';\nimport {\n  ComputedState,\n  LiftedAction,\n  LiftedActions,\n  LiftedState,\n} from './reducer';\n\nexport function difference(first: any[], second: any[]) {\n  return first.filter(item => second.indexOf(item) < 0);\n}\n\n/**\n * Provides an app's view into the state of the lifted store.\n */\nexport function unliftState(liftedState: LiftedState) {\n  const { computedStates, currentStateIndex } = liftedState;\n\n  // At start up NgRx dispatches init actions,\n  // When these init actions are being filtered out by the predicate or safe/block list options\n  // we don't have a complete computed states yet.\n  // At this point it could happen that we're out of bounds, when this happens we fall back to the last known state\n  if (currentStateIndex >= computedStates.length) {\n    const { state } = computedStates[computedStates.length - 1];\n    return state;\n  }\n\n  const { state } = computedStates[currentStateIndex];\n  return state;\n}\n\nexport function unliftAction(liftedState: LiftedState): LiftedAction {\n  return liftedState.actionsById[liftedState.nextActionId - 1];\n}\n\n/**\n * Lifts an app's action into an action on the lifted store.\n */\nexport function liftAction(action: Action) {\n  return new Actions.PerformAction(action, +Date.now());\n}\n\n/**\n * Sanitizes given actions with given function.\n */\nexport function sanitizeActions(\n  actionSanitizer: ActionSanitizer,\n  actions: LiftedActions\n): LiftedActions {\n  return Object.keys(actions).reduce(\n    (sanitizedActions, actionIdx) => {\n      const idx = Number(actionIdx);\n      sanitizedActions[idx] = sanitizeAction(\n        actionSanitizer,\n        actions[idx],\n        idx\n      );\n      return sanitizedActions;\n    },\n    <LiftedActions>{}\n  );\n}\n\n/**\n * Sanitizes given action with given function.\n */\nexport function sanitizeAction(\n  actionSanitizer: ActionSanitizer,\n  action: LiftedAction,\n  actionIdx: number\n): LiftedAction {\n  return {\n    ...action,\n    action: actionSanitizer(action.action, actionIdx),\n  };\n}\n\n/**\n * Sanitizes given states with given function.\n */\nexport function sanitizeStates(\n  stateSanitizer: StateSanitizer,\n  states: ComputedState[]\n): ComputedState[] {\n  return states.map((computedState, idx) => ({\n    state: sanitizeState(stateSanitizer, computedState.state, idx),\n    error: computedState.error,\n  }));\n}\n\n/**\n * Sanitizes given state with given function.\n */\nexport function sanitizeState(\n  stateSanitizer: StateSanitizer,\n  state: any,\n  stateIdx: number\n) {\n  return stateSanitizer(state, stateIdx);\n}\n\n/**\n * Read the config and tell if actions should be filtered\n */\nexport function shouldFilterActions(config: StoreDevtoolsConfig) {\n  return config.predicate || config.actionsSafelist || config.actionsBlocklist;\n}\n\n/**\n * Return a full filtered lifted state\n */\nexport function filterLiftedState(\n  liftedState: LiftedState,\n  predicate?: Predicate,\n  safelist?: string[],\n  blocklist?: string[]\n): LiftedState {\n  const filteredStagedActionIds: number[] = [];\n  const filteredActionsById: LiftedActions = {};\n  const filteredComputedStates: ComputedState[] = [];\n  liftedState.stagedActionIds.forEach((id, idx) => {\n    const liftedAction = liftedState.actionsById[id];\n    if (!liftedAction) return;\n    if (\n      idx &&\n      isActionFiltered(\n        liftedState.computedStates[idx],\n        liftedAction,\n        predicate,\n        safelist,\n        blocklist\n      )\n    ) {\n      return;\n    }\n    filteredActionsById[id] = liftedAction;\n    filteredStagedActionIds.push(id);\n    filteredComputedStates.push(liftedState.computedStates[idx]);\n  });\n  return {\n    ...liftedState,\n    stagedActionIds: filteredStagedActionIds,\n    actionsById: filteredActionsById,\n    computedStates: filteredComputedStates,\n  };\n}\n\n/**\n * Return true is the action should be ignored\n */\nexport function isActionFiltered(\n  state: any,\n  action: LiftedAction,\n  predicate?: Predicate,\n  safelist?: string[],\n  blockedlist?: string[]\n) {\n  const predicateMatch = predicate && !predicate(state, action.action);\n  const safelistMatch =\n    safelist &&\n    !action.action.type.match(safelist.map(s => escapeRegExp(s)).join('|'));\n  const blocklistMatch =\n    blockedlist &&\n    action.action.type.match(blockedlist.map(s => escapeRegExp(s)).join('|'));\n  return predicateMatch || safelistMatch || blocklistMatch;\n}\n\n/**\n * Return string with escaped RegExp special characters\n * https://stackoverflow.com/a/6969486/1337347\n */\nfunction escapeRegExp(s: string): string {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n","import { Inject, Injectable, InjectionToken } from '@angular/core';\nimport { Action, UPDATE } from '@ngrx/store';\nimport { empty, Observable, of } from 'rxjs';\nimport {\n  catchError,\n  concatMap,\n  debounceTime,\n  filter,\n  map,\n  share,\n  switchMap,\n  take,\n  takeUntil,\n  timeout,\n} from 'rxjs/operators';\n\nimport { IMPORT_STATE, PERFORM_ACTION } from './actions';\nimport {\n  SerializationOptions,\n  STORE_DEVTOOLS_CONFIG,\n  StoreDevtoolsConfig,\n} from './config';\nimport { DevtoolsDispatcher } from './devtools-dispatcher';\nimport { LiftedAction, LiftedState } from './reducer';\nimport {\n  isActionFiltered,\n  sanitizeAction,\n  sanitizeActions,\n  sanitizeState,\n  sanitizeStates,\n  shouldFilterActions,\n  unliftState,\n} from './utils';\n\nexport const ExtensionActionTypes = {\n  START: 'START',\n  DISPATCH: 'DISPATCH',\n  STOP: 'STOP',\n  ACTION: 'ACTION',\n};\n\nexport const REDUX_DEVTOOLS_EXTENSION = new InjectionToken<\n  ReduxDevtoolsExtension\n>('Redux Devtools Extension');\n\nexport interface ReduxDevtoolsExtensionConnection {\n  subscribe(listener: (change: any) => void): void;\n  unsubscribe(): void;\n  send(action: any, state: any): void;\n  init(state?: any): void;\n  error(anyErr: any): void;\n}\nexport interface ReduxDevtoolsExtensionConfig {\n  features?: object | boolean;\n  name: string | undefined;\n  maxAge?: number;\n  serialize?: boolean | SerializationOptions;\n}\n\nexport interface ReduxDevtoolsExtension {\n  connect(\n    options: ReduxDevtoolsExtensionConfig\n  ): ReduxDevtoolsExtensionConnection;\n  send(action: any, state: any, options: ReduxDevtoolsExtensionConfig): void;\n}\n\n@Injectable()\nexport class DevtoolsExtension {\n  private devtoolsExtension: ReduxDevtoolsExtension;\n  private extensionConnection!: ReduxDevtoolsExtensionConnection;\n\n  liftedActions$!: Observable<any>;\n  actions$!: Observable<any>;\n  start$!: Observable<any>;\n\n  constructor(\n    @Inject(REDUX_DEVTOOLS_EXTENSION) devtoolsExtension: ReduxDevtoolsExtension,\n    @Inject(STORE_DEVTOOLS_CONFIG) private config: StoreDevtoolsConfig,\n    private dispatcher: DevtoolsDispatcher\n  ) {\n    this.devtoolsExtension = devtoolsExtension;\n    this.createActionStreams();\n  }\n\n  notify(action: LiftedAction, state: LiftedState) {\n    if (!this.devtoolsExtension) {\n      return;\n    }\n    // Check to see if the action requires a full update of the liftedState.\n    // If it is a simple action generated by the user's app and the recording\n    // is not locked/paused, only send the action and the current state (fast).\n    //\n    // A full liftedState update (slow: serializes the entire liftedState) is\n    // only required when:\n    //   a) redux-devtools-extension fires the @@Init action (ignored by\n    //      @ngrx/store-devtools)\n    //   b) an action is generated by an @ngrx module (e.g. @ngrx/effects/init\n    //      or @ngrx/store/update-reducers)\n    //   c) the state has been recomputed due to time-traveling\n    //   d) any action that is not a PerformAction to err on the side of\n    //      caution.\n    if (action.type === PERFORM_ACTION) {\n      if (state.isLocked || state.isPaused) {\n        return;\n      }\n\n      const currentState = unliftState(state);\n      if (\n        shouldFilterActions(this.config) &&\n        isActionFiltered(\n          currentState,\n          action,\n          this.config.predicate,\n          this.config.actionsSafelist,\n          this.config.actionsBlocklist\n        )\n      ) {\n        return;\n      }\n      const sanitizedState = this.config.stateSanitizer\n        ? sanitizeState(\n            this.config.stateSanitizer,\n            currentState,\n            state.currentStateIndex\n          )\n        : currentState;\n      const sanitizedAction = this.config.actionSanitizer\n        ? sanitizeAction(\n            this.config.actionSanitizer,\n            action,\n            state.nextActionId\n          )\n        : action;\n\n      this.sendToReduxDevtools(() =>\n        this.extensionConnection.send(sanitizedAction, sanitizedState)\n      );\n    } else {\n      // Requires full state update\n      const sanitizedLiftedState = {\n        ...state,\n        stagedActionIds: state.stagedActionIds,\n        actionsById: this.config.actionSanitizer\n          ? sanitizeActions(this.config.actionSanitizer, state.actionsById)\n          : state.actionsById,\n        computedStates: this.config.stateSanitizer\n          ? sanitizeStates(this.config.stateSanitizer, state.computedStates)\n          : state.computedStates,\n      };\n\n      this.sendToReduxDevtools(() =>\n        this.devtoolsExtension.send(\n          null,\n          sanitizedLiftedState,\n          this.getExtensionConfig(this.config)\n        )\n      );\n    }\n  }\n\n  private createChangesObservable(): Observable<any> {\n    if (!this.devtoolsExtension) {\n      return empty();\n    }\n\n    return new Observable(subscriber => {\n      const connection = this.devtoolsExtension.connect(\n        this.getExtensionConfig(this.config)\n      );\n      this.extensionConnection = connection;\n      connection.init();\n\n      connection.subscribe((change: any) => subscriber.next(change));\n      return connection.unsubscribe;\n    });\n  }\n\n  private createActionStreams() {\n    // Listens to all changes\n    const changes$ = this.createChangesObservable().pipe(share());\n\n    // Listen for the start action\n    const start$ = changes$.pipe(\n      filter((change: any) => change.type === ExtensionActionTypes.START)\n    );\n\n    // Listen for the stop action\n    const stop$ = changes$.pipe(\n      filter((change: any) => change.type === ExtensionActionTypes.STOP)\n    );\n\n    // Listen for lifted actions\n    const liftedActions$ = changes$.pipe(\n      filter(change => change.type === ExtensionActionTypes.DISPATCH),\n      map(change => this.unwrapAction(change.payload)),\n      concatMap((action: any) => {\n        if (action.type === IMPORT_STATE) {\n          // State imports may happen in two situations:\n          // 1. Explicitly by user\n          // 2. User activated the \"persist state accross reloads\" option\n          //    and now the state is imported during reload.\n          // Because of option 2, we need to give possible\n          // lazy loaded reducers time to instantiate.\n          // As soon as there is no UPDATE action within 1 second,\n          // it is assumed that all reducers are loaded.\n          return this.dispatcher.pipe(\n            filter(action => action.type === UPDATE),\n            timeout(1000),\n            debounceTime(1000),\n            map(() => action),\n            catchError(() => of(action)),\n            take(1)\n          );\n        } else {\n          return of(action);\n        }\n      })\n    );\n\n    // Listen for unlifted actions\n    const actions$ = changes$.pipe(\n      filter(change => change.type === ExtensionActionTypes.ACTION),\n      map(change => this.unwrapAction(change.payload))\n    );\n\n    const actionsUntilStop$ = actions$.pipe(takeUntil(stop$));\n    const liftedUntilStop$ = liftedActions$.pipe(takeUntil(stop$));\n    this.start$ = start$.pipe(takeUntil(stop$));\n\n    // Only take the action sources between the start/stop events\n    this.actions$ = this.start$.pipe(switchMap(() => actionsUntilStop$));\n    this.liftedActions$ = this.start$.pipe(switchMap(() => liftedUntilStop$));\n  }\n\n  private unwrapAction(action: Action) {\n    return typeof action === 'string' ? eval(`(${action})`) : action;\n  }\n\n  private getExtensionConfig(config: StoreDevtoolsConfig) {\n    const extensionOptions: ReduxDevtoolsExtensionConfig = {\n      name: config.name,\n      features: config.features,\n      serialize: config.serialize,\n      // The action/state sanitizers are not added to the config\n      // because sanitation is done in this class already.\n      // It is done before sending it to the devtools extension for consistency:\n      // - If we call extensionConnection.send(...),\n      //   the extension would call the sanitizers.\n      // - If we call devtoolsExtension.send(...) (aka full state update),\n      //   the extension would NOT call the sanitizers, so we have to do it ourselves.\n    };\n    if (config.maxAge !== false /* support === 0 */) {\n      extensionOptions.maxAge = config.maxAge;\n    }\n    return extensionOptions;\n  }\n\n  private sendToReduxDevtools(send: Function) {\n    try {\n      send();\n    } catch (err) {\n      console.warn(\n        '@ngrx/store-devtools: something went wrong inside the redux devtools',\n        err\n      );\n    }\n  }\n}\n","import { ErrorHandler } from '@angular/core';\nimport { Action, ActionReducer, UPDATE, INIT } from '@ngrx/store';\n\nimport { difference, liftAction, isActionFiltered } from './utils';\nimport * as DevtoolsActions from './actions';\nimport { StoreDevtoolsConfig } from './config';\nimport { PerformAction } from './actions';\n\nexport type InitAction = {\n  readonly type: typeof INIT;\n};\n\nexport type UpdateReducerAction = {\n  readonly type: typeof UPDATE;\n};\n\nexport type CoreActions = InitAction | UpdateReducerAction;\nexport type Actions = DevtoolsActions.All | CoreActions;\n\nexport const INIT_ACTION = { type: INIT };\n\nexport const RECOMPUTE = '@ngrx/store-devtools/recompute' as '@ngrx/store-devtools/recompute';\nexport const RECOMPUTE_ACTION = { type: RECOMPUTE };\n\nexport interface ComputedState {\n  state: any;\n  error: any;\n}\n\nexport interface LiftedAction {\n  type: string;\n  action: Action;\n}\n\nexport interface LiftedActions {\n  [id: number]: LiftedAction;\n}\n\nexport interface LiftedState {\n  monitorState: any;\n  nextActionId: number;\n  actionsById: LiftedActions;\n  stagedActionIds: number[];\n  skippedActionIds: number[];\n  committedState: any;\n  currentStateIndex: number;\n  computedStates: ComputedState[];\n  isLocked: boolean;\n  isPaused: boolean;\n}\n\n/**\n * Computes the next entry in the log by applying an action.\n */\nfunction computeNextEntry(\n  reducer: ActionReducer<any, any>,\n  action: Action,\n  state: any,\n  error: any,\n  errorHandler: ErrorHandler\n) {\n  if (error) {\n    return {\n      state,\n      error: 'Interrupted by an error up the chain',\n    };\n  }\n\n  let nextState = state;\n  let nextError;\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n    errorHandler.handleError(err.stack || err);\n  }\n\n  return {\n    state: nextState,\n    error: nextError,\n  };\n}\n\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\nfunction recomputeStates(\n  computedStates: ComputedState[],\n  minInvalidatedStateIndex: number,\n  reducer: ActionReducer<any, any>,\n  committedState: any,\n  actionsById: LiftedActions,\n  stagedActionIds: number[],\n  skippedActionIds: number[],\n  errorHandler: ErrorHandler,\n  isPaused: boolean\n) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (\n    minInvalidatedStateIndex >= computedStates.length &&\n    computedStates.length === stagedActionIds.length\n  ) {\n    return computedStates;\n  }\n\n  const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n  // If the recording is paused, recompute all states up until the pause state,\n  // else recompute all states.\n  const lastIncludedActionId = stagedActionIds.length - (isPaused ? 1 : 0);\n  for (let i = minInvalidatedStateIndex; i < lastIncludedActionId; i++) {\n    const actionId = stagedActionIds[i];\n    const action = actionsById[actionId].action;\n\n    const previousEntry = nextComputedStates[i - 1];\n    const previousState = previousEntry ? previousEntry.state : committedState;\n    const previousError = previousEntry ? previousEntry.error : undefined;\n\n    const shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    const entry: ComputedState = shouldSkip\n      ? previousEntry\n      : computeNextEntry(\n          reducer,\n          action,\n          previousState,\n          previousError,\n          errorHandler\n        );\n\n    nextComputedStates.push(entry);\n  }\n  // If the recording is paused, the last state will not be recomputed,\n  // because it's essentially not part of the state history.\n  if (isPaused) {\n    nextComputedStates.push(computedStates[computedStates.length - 1]);\n  }\n\n  return nextComputedStates;\n}\n\nexport function liftInitialState(\n  initialCommittedState?: any,\n  monitorReducer?: any\n): LiftedState {\n  return {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: { 0: liftAction(INIT_ACTION) },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: false,\n    isPaused: false,\n  };\n}\n\n/**\n * Creates a history state reducer from an app's reducer.\n */\nexport function liftReducerWith(\n  initialCommittedState: any,\n  initialLiftedState: LiftedState,\n  errorHandler: ErrorHandler,\n  monitorReducer?: any,\n  options: Partial<StoreDevtoolsConfig> = {}\n) {\n  /**\n   * Manages how the history actions modify the history state.\n   */\n  return (\n    reducer: ActionReducer<any, any>\n  ): ActionReducer<LiftedState, Actions> => (liftedState, liftedAction) => {\n    let {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused,\n    } =\n      liftedState || initialLiftedState;\n\n    if (!liftedState) {\n      // Prevent mutating initialLiftedState\n      actionsById = Object.create(actionsById);\n    }\n\n    function commitExcessActions(n: number) {\n      // Auto-commits n-number of excess actions.\n      let excess = n;\n      let idsToDelete = stagedActionIds.slice(1, excess + 1);\n\n      for (let i = 0; i < idsToDelete.length; i++) {\n        if (computedStates[i + 1].error) {\n          // Stop if error is found. Commit actions up to error.\n          excess = i;\n          idsToDelete = stagedActionIds.slice(1, excess + 1);\n          break;\n        } else {\n          delete actionsById[idsToDelete[i]];\n        }\n      }\n\n      skippedActionIds = skippedActionIds.filter(\n        id => idsToDelete.indexOf(id) === -1\n      );\n      stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];\n      committedState = computedStates[excess].state;\n      computedStates = computedStates.slice(excess);\n      currentStateIndex =\n        currentStateIndex > excess ? currentStateIndex - excess : 0;\n    }\n\n    function commitChanges() {\n      // Consider the last committed state the new starting point.\n      // Squash any staged actions into a single committed state.\n      actionsById = { 0: liftAction(INIT_ACTION) };\n      nextActionId = 1;\n      stagedActionIds = [0];\n      skippedActionIds = [];\n      committedState = computedStates[currentStateIndex].state;\n      currentStateIndex = 0;\n      computedStates = [];\n    }\n\n    // By default, aggressively recompute every state whatever happens.\n    // This has O(n) performance, so we'll override this to a sensible\n    // value whenever we feel like we don't have to recompute the states.\n    let minInvalidatedStateIndex = 0;\n\n    switch (liftedAction.type) {\n      case DevtoolsActions.LOCK_CHANGES: {\n        isLocked = liftedAction.status;\n        minInvalidatedStateIndex = Infinity;\n        break;\n      }\n      case DevtoolsActions.PAUSE_RECORDING: {\n        isPaused = liftedAction.status;\n        if (isPaused) {\n          // Add a pause action to signal the devtools-user the recording is paused.\n          // The corresponding state will be overwritten on each update to always contain\n          // the latest state (see Actions.PERFORM_ACTION).\n          stagedActionIds = [...stagedActionIds, nextActionId];\n          actionsById[nextActionId] = new PerformAction(\n            {\n              type: '@ngrx/devtools/pause',\n            },\n            +Date.now()\n          );\n          nextActionId++;\n          minInvalidatedStateIndex = stagedActionIds.length - 1;\n          computedStates = computedStates.concat(\n            computedStates[computedStates.length - 1]\n          );\n\n          if (currentStateIndex === stagedActionIds.length - 2) {\n            currentStateIndex++;\n          }\n          minInvalidatedStateIndex = Infinity;\n        } else {\n          commitChanges();\n        }\n        break;\n      }\n      case DevtoolsActions.RESET: {\n        // Get back to the state the store was created with.\n        actionsById = { 0: liftAction(INIT_ACTION) };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = initialCommittedState;\n        currentStateIndex = 0;\n        computedStates = [];\n        break;\n      }\n      case DevtoolsActions.COMMIT: {\n        commitChanges();\n        break;\n      }\n      case DevtoolsActions.ROLLBACK: {\n        // Forget about any staged actions.\n        // Start again from the last committed state.\n        actionsById = { 0: liftAction(INIT_ACTION) };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        currentStateIndex = 0;\n        computedStates = [];\n        break;\n      }\n      case DevtoolsActions.TOGGLE_ACTION: {\n        // Toggle whether an action with given ID is skipped.\n        // Being skipped means it is a no-op during the computation.\n        const { id: actionId } = liftedAction;\n        const index = skippedActionIds.indexOf(actionId);\n        if (index === -1) {\n          skippedActionIds = [actionId, ...skippedActionIds];\n        } else {\n          skippedActionIds = skippedActionIds.filter(id => id !== actionId);\n        }\n        // Optimization: we know history before this action hasn't changed\n        minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n        break;\n      }\n      case DevtoolsActions.SET_ACTIONS_ACTIVE: {\n        // Toggle whether an action with given ID is skipped.\n        // Being skipped means it is a no-op during the computation.\n        const { start, end, active } = liftedAction;\n        const actionIds = [];\n        for (let i = start; i < end; i++) actionIds.push(i);\n        if (active) {\n          skippedActionIds = difference(skippedActionIds, actionIds);\n        } else {\n          skippedActionIds = [...skippedActionIds, ...actionIds];\n        }\n\n        // Optimization: we know history before this action hasn't changed\n        minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n        break;\n      }\n      case DevtoolsActions.JUMP_TO_STATE: {\n        // Without recomputing anything, move the pointer that tell us\n        // which state is considered the current one. Useful for sliders.\n        currentStateIndex = liftedAction.index;\n        // Optimization: we know the history has not changed.\n        minInvalidatedStateIndex = Infinity;\n        break;\n      }\n      case DevtoolsActions.JUMP_TO_ACTION: {\n        // Jumps to a corresponding state to a specific action.\n        // Useful when filtering actions.\n        const index = stagedActionIds.indexOf(liftedAction.actionId);\n        if (index !== -1) currentStateIndex = index;\n        minInvalidatedStateIndex = Infinity;\n        break;\n      }\n      case DevtoolsActions.SWEEP: {\n        // Forget any actions that are currently being skipped.\n        stagedActionIds = difference(stagedActionIds, skippedActionIds);\n        skippedActionIds = [];\n        currentStateIndex = Math.min(\n          currentStateIndex,\n          stagedActionIds.length - 1\n        );\n        break;\n      }\n      case DevtoolsActions.PERFORM_ACTION: {\n        // Ignore action and return state as is if recording is locked\n        if (isLocked) {\n          return liftedState || initialLiftedState;\n        }\n\n        if (\n          isPaused ||\n          (liftedState &&\n            isActionFiltered(\n              liftedState.computedStates[currentStateIndex],\n              liftedAction,\n              options.predicate,\n              options.actionsSafelist,\n              options.actionsBlocklist\n            ))\n        ) {\n          // If recording is paused or if the action should be ignored, overwrite the last state\n          // (corresponds to the pause action) and keep everything else as is.\n          // This way, the app gets the new current state while the devtools\n          // do not record another action.\n          const lastState = computedStates[computedStates.length - 1];\n          computedStates = [\n            ...computedStates.slice(0, -1),\n            computeNextEntry(\n              reducer,\n              liftedAction.action,\n              lastState.state,\n              lastState.error,\n              errorHandler\n            ),\n          ];\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n\n        // Auto-commit as new actions come in.\n        if (options.maxAge && stagedActionIds.length === options.maxAge) {\n          commitExcessActions(1);\n        }\n\n        if (currentStateIndex === stagedActionIds.length - 1) {\n          currentStateIndex++;\n        }\n        const actionId = nextActionId++;\n        // Mutation! This is the hottest path, and we optimize on purpose.\n        // It is safe because we set a new key in a cache dictionary.\n        actionsById[actionId] = liftedAction;\n\n        stagedActionIds = [...stagedActionIds, actionId];\n        // Optimization: we know that only the new action needs computing.\n        minInvalidatedStateIndex = stagedActionIds.length - 1;\n        break;\n      }\n      case DevtoolsActions.IMPORT_STATE: {\n        // Completely replace everything.\n        ({\n          monitorState,\n          actionsById,\n          nextActionId,\n          stagedActionIds,\n          skippedActionIds,\n          committedState,\n          currentStateIndex,\n          computedStates,\n          isLocked,\n          // prettier-ignore\n          isPaused\n        } = liftedAction.nextLiftedState);\n        break;\n      }\n      case INIT: {\n        // Always recompute states on hot reload and init.\n        minInvalidatedStateIndex = 0;\n\n        if (options.maxAge && stagedActionIds.length > options.maxAge) {\n          // States must be recomputed before committing excess.\n          computedStates = recomputeStates(\n            computedStates,\n            minInvalidatedStateIndex,\n            reducer,\n            committedState,\n            actionsById,\n            stagedActionIds,\n            skippedActionIds,\n            errorHandler,\n            isPaused\n          );\n\n          commitExcessActions(stagedActionIds.length - options.maxAge);\n\n          // Avoid double computation.\n          minInvalidatedStateIndex = Infinity;\n        }\n\n        break;\n      }\n      case UPDATE: {\n        const stateHasErrors =\n          computedStates.filter(state => state.error).length > 0;\n\n        if (stateHasErrors) {\n          // Recompute all states\n          minInvalidatedStateIndex = 0;\n\n          if (options.maxAge && stagedActionIds.length > options.maxAge) {\n            // States must be recomputed before committing excess.\n            computedStates = recomputeStates(\n              computedStates,\n              minInvalidatedStateIndex,\n              reducer,\n              committedState,\n              actionsById,\n              stagedActionIds,\n              skippedActionIds,\n              errorHandler,\n              isPaused\n            );\n\n            commitExcessActions(stagedActionIds.length - options.maxAge);\n\n            // Avoid double computation.\n            minInvalidatedStateIndex = Infinity;\n          }\n        } else {\n          // If not paused/locked, add a new action to signal devtools-user\n          // that there was a reducer update.\n          if (!isPaused && !isLocked) {\n            if (currentStateIndex === stagedActionIds.length - 1) {\n              currentStateIndex++;\n            }\n\n            // Add a new action to only recompute state\n            const actionId = nextActionId++;\n            actionsById[actionId] = new PerformAction(\n              liftedAction,\n              +Date.now()\n            );\n            stagedActionIds = [...stagedActionIds, actionId];\n\n            minInvalidatedStateIndex = stagedActionIds.length - 1;\n\n            computedStates = recomputeStates(\n              computedStates,\n              minInvalidatedStateIndex,\n              reducer,\n              committedState,\n              actionsById,\n              stagedActionIds,\n              skippedActionIds,\n              errorHandler,\n              isPaused\n            );\n          }\n\n          // Recompute state history with latest reducer and update action\n          computedStates = computedStates.map(cmp => ({\n            ...cmp,\n            state: reducer(cmp.state, RECOMPUTE_ACTION),\n          }));\n\n          currentStateIndex = stagedActionIds.length - 1;\n\n          if (options.maxAge && stagedActionIds.length > options.maxAge) {\n            commitExcessActions(stagedActionIds.length - options.maxAge);\n          }\n\n          // Avoid double computation.\n          minInvalidatedStateIndex = Infinity;\n        }\n\n        break;\n      }\n      default: {\n        // If the action is not recognized, it's a monitor action.\n        // Optimization: a monitor action can't change history.\n        minInvalidatedStateIndex = Infinity;\n        break;\n      }\n    }\n\n    computedStates = recomputeStates(\n      computedStates,\n      minInvalidatedStateIndex,\n      reducer,\n      committedState,\n      actionsById,\n      stagedActionIds,\n      skippedActionIds,\n      errorHandler,\n      isPaused\n    );\n    monitorState = monitorReducer(monitorState, liftedAction);\n\n    return {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused,\n    };\n  };\n}\n","import { Injectable, Inject, ErrorHandler } from '@angular/core';\nimport {\n  Action,\n  ActionReducer,\n  ActionsSubject,\n  INITIAL_STATE,\n  ReducerObservable,\n  ScannedActionsSubject,\n} from '@ngrx/store';\nimport {\n  merge,\n  Observable,\n  Observer,\n  queueScheduler,\n  ReplaySubject,\n  Subscription,\n} from 'rxjs';\nimport { map, observeOn, scan, skip, withLatestFrom } from 'rxjs/operators';\n\nimport * as Actions from './actions';\nimport { STORE_DEVTOOLS_CONFIG, StoreDevtoolsConfig } from './config';\nimport { DevtoolsExtension } from './extension';\nimport { LiftedState, liftInitialState, liftReducerWith } from './reducer';\nimport {\n  liftAction,\n  unliftState,\n  shouldFilterActions,\n  filterLiftedState,\n} from './utils';\nimport { DevtoolsDispatcher } from './devtools-dispatcher';\nimport { PERFORM_ACTION } from './actions';\n\n@Injectable()\nexport class StoreDevtools implements Observer<any> {\n  private stateSubscription: Subscription;\n  private extensionStartSubscription: Subscription;\n  public dispatcher: ActionsSubject;\n  public liftedState: Observable<LiftedState>;\n  public state: Observable<any>;\n\n  constructor(\n    dispatcher: DevtoolsDispatcher,\n    actions$: ActionsSubject,\n    reducers$: ReducerObservable,\n    extension: DevtoolsExtension,\n    scannedActions: ScannedActionsSubject,\n    errorHandler: ErrorHandler,\n    @Inject(INITIAL_STATE) initialState: any,\n    @Inject(STORE_DEVTOOLS_CONFIG) config: StoreDevtoolsConfig\n  ) {\n    const liftedInitialState = liftInitialState(initialState, config.monitor);\n    const liftReducer = liftReducerWith(\n      initialState,\n      liftedInitialState,\n      errorHandler,\n      config.monitor,\n      config\n    );\n\n    const liftedAction$ = merge(\n      merge(actions$.asObservable().pipe(skip(1)), extension.actions$).pipe(\n        map(liftAction)\n      ),\n      dispatcher,\n      extension.liftedActions$\n    ).pipe(observeOn(queueScheduler));\n\n    const liftedReducer$ = reducers$.pipe(map(liftReducer));\n\n    const liftedStateSubject = new ReplaySubject<LiftedState>(1);\n\n    const liftedStateSubscription = liftedAction$\n      .pipe(\n        withLatestFrom(liftedReducer$),\n        scan<\n          [any, ActionReducer<LiftedState, Actions.All>],\n          {\n            state: LiftedState;\n            action: any;\n          }\n        >(\n          ({ state: liftedState }, [action, reducer]) => {\n            let reducedLiftedState = reducer(liftedState, action);\n            // On full state update\n            // If we have actions filters, we must filter completely our lifted state to be sync with the extension\n            if (action.type !== PERFORM_ACTION && shouldFilterActions(config)) {\n              reducedLiftedState = filterLiftedState(\n                reducedLiftedState,\n                config.predicate,\n                config.actionsSafelist,\n                config.actionsBlocklist\n              );\n            }\n            // Extension should be sent the sanitized lifted state\n            extension.notify(action, reducedLiftedState);\n            return { state: reducedLiftedState, action };\n          },\n          { state: liftedInitialState, action: null as any }\n        )\n      )\n      .subscribe(({ state, action }) => {\n        liftedStateSubject.next(state);\n\n        if (action.type === Actions.PERFORM_ACTION) {\n          const unliftedAction = (action as Actions.PerformAction).action;\n\n          scannedActions.next(unliftedAction);\n        }\n      });\n\n    const extensionStartSubscription = extension.start$.subscribe(() => {\n      this.refresh();\n    });\n\n    const liftedState$ = liftedStateSubject.asObservable() as Observable<\n      LiftedState\n    >;\n    const state$ = liftedState$.pipe(map(unliftState));\n\n    this.extensionStartSubscription = extensionStartSubscription;\n    this.stateSubscription = liftedStateSubscription;\n    this.dispatcher = dispatcher;\n    this.liftedState = liftedState$;\n    this.state = state$;\n  }\n\n  dispatch(action: Action) {\n    this.dispatcher.next(action);\n  }\n\n  next(action: any) {\n    this.dispatcher.next(action);\n  }\n\n  error(error: any) {}\n\n  complete() {}\n\n  performAction(action: any) {\n    this.dispatch(new Actions.PerformAction(action, +Date.now()));\n  }\n\n  refresh() {\n    this.dispatch(new Actions.Refresh());\n  }\n\n  reset() {\n    this.dispatch(new Actions.Reset(+Date.now()));\n  }\n\n  rollback() {\n    this.dispatch(new Actions.Rollback(+Date.now()));\n  }\n\n  commit() {\n    this.dispatch(new Actions.Commit(+Date.now()));\n  }\n\n  sweep() {\n    this.dispatch(new Actions.Sweep());\n  }\n\n  toggleAction(id: number) {\n    this.dispatch(new Actions.ToggleAction(id));\n  }\n\n  jumpToAction(actionId: number) {\n    this.dispatch(new Actions.JumpToAction(actionId));\n  }\n\n  jumpToState(index: number) {\n    this.dispatch(new Actions.JumpToState(index));\n  }\n\n  importState(nextLiftedState: any) {\n    this.dispatch(new Actions.ImportState(nextLiftedState));\n  }\n\n  lockChanges(status: boolean) {\n    this.dispatch(new Actions.LockChanges(status));\n  }\n\n  pauseRecording(status: boolean) {\n    this.dispatch(new Actions.PauseRecording(status));\n  }\n}\n","import { InjectionToken, ModuleWithProviders, NgModule } from '@angular/core';\nimport { ReducerManagerDispatcher, StateObservable } from '@ngrx/store';\nimport { Observable } from 'rxjs';\n\nimport {\n  INITIAL_OPTIONS,\n  STORE_DEVTOOLS_CONFIG,\n  StoreDevtoolsConfig,\n  StoreDevtoolsOptions,\n  noMonitor,\n  createConfig,\n} from './config';\nimport { StoreDevtools } from './devtools';\nimport {\n  DevtoolsExtension,\n  REDUX_DEVTOOLS_EXTENSION,\n  ReduxDevtoolsExtension,\n} from './extension';\nimport { DevtoolsDispatcher } from './devtools-dispatcher';\n\nexport const IS_EXTENSION_OR_MONITOR_PRESENT = new InjectionToken<boolean>(\n  'Is Devtools Extension or Monitor Present'\n);\n\nexport function createIsExtensionOrMonitorPresent(\n  extension: ReduxDevtoolsExtension | null,\n  config: StoreDevtoolsConfig\n) {\n  return Boolean(extension) || config.monitor !== noMonitor;\n}\n\nexport function createReduxDevtoolsExtension() {\n  const extensionKey = '__REDUX_DEVTOOLS_EXTENSION__';\n\n  if (\n    typeof window === 'object' &&\n    typeof (window as any)[extensionKey] !== 'undefined'\n  ) {\n    return (window as any)[extensionKey];\n  } else {\n    return null;\n  }\n}\n\nexport function createStateObservable(\n  devtools: StoreDevtools\n): Observable<any> {\n  return devtools.state;\n}\n\n@NgModule({})\nexport class StoreDevtoolsModule {\n  static instrument(\n    options: StoreDevtoolsOptions = {}\n  ): ModuleWithProviders<StoreDevtoolsModule> {\n    return {\n      ngModule: StoreDevtoolsModule,\n      providers: [\n        DevtoolsExtension,\n        DevtoolsDispatcher,\n        StoreDevtools,\n        {\n          provide: INITIAL_OPTIONS,\n          useValue: options,\n        },\n        {\n          provide: IS_EXTENSION_OR_MONITOR_PRESENT,\n          deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],\n          useFactory: createIsExtensionOrMonitorPresent,\n        },\n        {\n          provide: REDUX_DEVTOOLS_EXTENSION,\n          useFactory: createReduxDevtoolsExtension,\n        },\n        {\n          provide: STORE_DEVTOOLS_CONFIG,\n          deps: [INITIAL_OPTIONS],\n          useFactory: createConfig,\n        },\n        {\n          provide: StateObservable,\n          deps: [StoreDevtools],\n          useFactory: createStateObservable,\n        },\n        {\n          provide: ReducerManagerDispatcher,\n          useExisting: DevtoolsDispatcher,\n        },\n      ],\n    };\n  }\n}\n"]}