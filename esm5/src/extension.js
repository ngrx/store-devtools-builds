var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
/**
 * @fileoverview added by tsickle
 * Generated from: src/extension.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Inject, Injectable, InjectionToken } from '@angular/core';
import { UPDATE } from '@ngrx/store';
import { empty, Observable, of } from 'rxjs';
import { catchError, concatMap, debounceTime, filter, map, share, switchMap, take, takeUntil, timeout, } from 'rxjs/operators';
import { IMPORT_STATE, PERFORM_ACTION } from './actions';
import { STORE_DEVTOOLS_CONFIG, StoreDevtoolsConfig, } from './config';
import { DevtoolsDispatcher } from './devtools-dispatcher';
import { isActionFiltered, sanitizeAction, sanitizeActions, sanitizeState, sanitizeStates, shouldFilterActions, unliftState, } from './utils';
/** @type {?} */
export var ExtensionActionTypes = {
    START: 'START',
    DISPATCH: 'DISPATCH',
    STOP: 'STOP',
    ACTION: 'ACTION',
};
/** @type {?} */
export var REDUX_DEVTOOLS_EXTENSION = new InjectionToken('Redux Devtools Extension');
/**
 * @record
 */
export function ReduxDevtoolsExtensionConnection() { }
if (false) {
    /**
     * @param {?} listener
     * @return {?}
     */
    ReduxDevtoolsExtensionConnection.prototype.subscribe = function (listener) { };
    /**
     * @return {?}
     */
    ReduxDevtoolsExtensionConnection.prototype.unsubscribe = function () { };
    /**
     * @param {?} action
     * @param {?} state
     * @return {?}
     */
    ReduxDevtoolsExtensionConnection.prototype.send = function (action, state) { };
    /**
     * @param {?=} state
     * @return {?}
     */
    ReduxDevtoolsExtensionConnection.prototype.init = function (state) { };
    /**
     * @param {?} anyErr
     * @return {?}
     */
    ReduxDevtoolsExtensionConnection.prototype.error = function (anyErr) { };
}
/**
 * @record
 */
export function ReduxDevtoolsExtensionConfig() { }
if (false) {
    /** @type {?|undefined} */
    ReduxDevtoolsExtensionConfig.prototype.features;
    /** @type {?} */
    ReduxDevtoolsExtensionConfig.prototype.name;
    /** @type {?|undefined} */
    ReduxDevtoolsExtensionConfig.prototype.maxAge;
    /** @type {?|undefined} */
    ReduxDevtoolsExtensionConfig.prototype.serialize;
}
/**
 * @record
 */
export function ReduxDevtoolsExtension() { }
if (false) {
    /**
     * @param {?} options
     * @return {?}
     */
    ReduxDevtoolsExtension.prototype.connect = function (options) { };
    /**
     * @param {?} action
     * @param {?} state
     * @param {?} options
     * @return {?}
     */
    ReduxDevtoolsExtension.prototype.send = function (action, state, options) { };
}
var DevtoolsExtension = /** @class */ (function () {
    function DevtoolsExtension(devtoolsExtension, config, dispatcher) {
        this.config = config;
        this.dispatcher = dispatcher;
        this.devtoolsExtension = devtoolsExtension;
        this.createActionStreams();
    }
    /**
     * @param {?} action
     * @param {?} state
     * @return {?}
     */
    DevtoolsExtension.prototype.notify = /**
     * @param {?} action
     * @param {?} state
     * @return {?}
     */
    function (action, state) {
        var _this = this;
        if (!this.devtoolsExtension) {
            return;
        }
        // Check to see if the action requires a full update of the liftedState.
        // If it is a simple action generated by the user's app and the recording
        // is not locked/paused, only send the action and the current state (fast).
        //
        // A full liftedState update (slow: serializes the entire liftedState) is
        // only required when:
        //   a) redux-devtools-extension fires the @@Init action (ignored by
        //      @ngrx/store-devtools)
        //   b) an action is generated by an @ngrx module (e.g. @ngrx/effects/init
        //      or @ngrx/store/update-reducers)
        //   c) the state has been recomputed due to time-traveling
        //   d) any action that is not a PerformAction to err on the side of
        //      caution.
        if (action.type === PERFORM_ACTION) {
            if (state.isLocked || state.isPaused) {
                return;
            }
            /** @type {?} */
            var currentState = unliftState(state);
            if (shouldFilterActions(this.config) &&
                isActionFiltered(currentState, action, this.config.predicate, this.config.actionsSafelist, this.config.actionsBlocklist)) {
                return;
            }
            /** @type {?} */
            var sanitizedState_1 = this.config.stateSanitizer
                ? sanitizeState(this.config.stateSanitizer, currentState, state.currentStateIndex)
                : currentState;
            /** @type {?} */
            var sanitizedAction_1 = this.config.actionSanitizer
                ? sanitizeAction(this.config.actionSanitizer, action, state.nextActionId)
                : action;
            this.sendToReduxDevtools((/**
             * @return {?}
             */
            function () {
                return _this.extensionConnection.send(sanitizedAction_1, sanitizedState_1);
            }));
        }
        else {
            // Requires full state update
            /** @type {?} */
            var sanitizedLiftedState_1 = __assign(__assign({}, state), { stagedActionIds: state.stagedActionIds, actionsById: this.config.actionSanitizer
                    ? sanitizeActions(this.config.actionSanitizer, state.actionsById)
                    : state.actionsById, computedStates: this.config.stateSanitizer
                    ? sanitizeStates(this.config.stateSanitizer, state.computedStates)
                    : state.computedStates });
            this.sendToReduxDevtools((/**
             * @return {?}
             */
            function () {
                return _this.devtoolsExtension.send(null, sanitizedLiftedState_1, _this.getExtensionConfig(_this.config));
            }));
        }
    };
    /**
     * @private
     * @return {?}
     */
    DevtoolsExtension.prototype.createChangesObservable = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.devtoolsExtension) {
            return empty();
        }
        return new Observable((/**
         * @param {?} subscriber
         * @return {?}
         */
        function (subscriber) {
            /** @type {?} */
            var connection = _this.devtoolsExtension.connect(_this.getExtensionConfig(_this.config));
            _this.extensionConnection = connection;
            connection.init();
            connection.subscribe((/**
             * @param {?} change
             * @return {?}
             */
            function (change) { return subscriber.next(change); }));
            return connection.unsubscribe;
        }));
    };
    /**
     * @private
     * @return {?}
     */
    DevtoolsExtension.prototype.createActionStreams = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        // Listens to all changes
        /** @type {?} */
        var changes$ = this.createChangesObservable().pipe(share());
        // Listen for the start action
        /** @type {?} */
        var start$ = changes$.pipe(filter((/**
         * @param {?} change
         * @return {?}
         */
        function (change) { return change.type === ExtensionActionTypes.START; })));
        // Listen for the stop action
        /** @type {?} */
        var stop$ = changes$.pipe(filter((/**
         * @param {?} change
         * @return {?}
         */
        function (change) { return change.type === ExtensionActionTypes.STOP; })));
        // Listen for lifted actions
        /** @type {?} */
        var liftedActions$ = changes$.pipe(filter((/**
         * @param {?} change
         * @return {?}
         */
        function (change) { return change.type === ExtensionActionTypes.DISPATCH; })), map((/**
         * @param {?} change
         * @return {?}
         */
        function (change) { return _this.unwrapAction(change.payload); })), concatMap((/**
         * @param {?} action
         * @return {?}
         */
        function (action) {
            if (action.type === IMPORT_STATE) {
                // State imports may happen in two situations:
                // 1. Explicitly by user
                // 2. User activated the "persist state accross reloads" option
                //    and now the state is imported during reload.
                // Because of option 2, we need to give possible
                // lazy loaded reducers time to instantiate.
                // As soon as there is no UPDATE action within 1 second,
                // it is assumed that all reducers are loaded.
                return _this.dispatcher.pipe(filter((/**
                 * @param {?} action
                 * @return {?}
                 */
                function (action) { return action.type === UPDATE; })), timeout(1000), debounceTime(1000), map((/**
                 * @return {?}
                 */
                function () { return action; })), catchError((/**
                 * @return {?}
                 */
                function () { return of(action); })), take(1));
            }
            else {
                return of(action);
            }
        })));
        // Listen for unlifted actions
        /** @type {?} */
        var actions$ = changes$.pipe(filter((/**
         * @param {?} change
         * @return {?}
         */
        function (change) { return change.type === ExtensionActionTypes.ACTION; })), map((/**
         * @param {?} change
         * @return {?}
         */
        function (change) { return _this.unwrapAction(change.payload); })));
        /** @type {?} */
        var actionsUntilStop$ = actions$.pipe(takeUntil(stop$));
        /** @type {?} */
        var liftedUntilStop$ = liftedActions$.pipe(takeUntil(stop$));
        this.start$ = start$.pipe(takeUntil(stop$));
        // Only take the action sources between the start/stop events
        this.actions$ = this.start$.pipe(switchMap((/**
         * @return {?}
         */
        function () { return actionsUntilStop$; })));
        this.liftedActions$ = this.start$.pipe(switchMap((/**
         * @return {?}
         */
        function () { return liftedUntilStop$; })));
    };
    /**
     * @private
     * @param {?} action
     * @return {?}
     */
    DevtoolsExtension.prototype.unwrapAction = /**
     * @private
     * @param {?} action
     * @return {?}
     */
    function (action) {
        return typeof action === 'string' ? eval("(" + action + ")") : action;
    };
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    DevtoolsExtension.prototype.getExtensionConfig = /**
     * @private
     * @param {?} config
     * @return {?}
     */
    function (config) {
        /** @type {?} */
        var extensionOptions = {
            name: config.name,
            features: config.features,
            serialize: config.serialize,
        };
        if (config.maxAge !== false /* support === 0 */) {
            extensionOptions.maxAge = config.maxAge;
        }
        return extensionOptions;
    };
    /**
     * @private
     * @param {?} send
     * @return {?}
     */
    DevtoolsExtension.prototype.sendToReduxDevtools = /**
     * @private
     * @param {?} send
     * @return {?}
     */
    function (send) {
        try {
            send();
        }
        catch (err) {
            console.warn('@ngrx/store-devtools: something went wrong inside the redux devtools', err);
        }
    };
    DevtoolsExtension.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    DevtoolsExtension.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [REDUX_DEVTOOLS_EXTENSION,] }] },
        { type: StoreDevtoolsConfig, decorators: [{ type: Inject, args: [STORE_DEVTOOLS_CONFIG,] }] },
        { type: DevtoolsDispatcher }
    ]; };
    return DevtoolsExtension;
}());
export { DevtoolsExtension };
if (false) {
    /**
     * @type {?}
     * @private
     */
    DevtoolsExtension.prototype.devtoolsExtension;
    /**
     * @type {?}
     * @private
     */
    DevtoolsExtension.prototype.extensionConnection;
    /** @type {?} */
    DevtoolsExtension.prototype.liftedActions$;
    /** @type {?} */
    DevtoolsExtension.prototype.actions$;
    /** @type {?} */
    DevtoolsExtension.prototype.start$;
    /**
     * @type {?}
     * @private
     */
    DevtoolsExtension.prototype.config;
    /**
     * @type {?}
     * @private
     */
    DevtoolsExtension.prototype.dispatcher;
}
//# sourceMappingURL=extension.js.map