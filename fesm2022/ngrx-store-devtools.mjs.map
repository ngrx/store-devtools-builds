{
  "version": 3,
  "sources": ["../../../../modules/store-devtools/src/actions.ts", "../../../../modules/store-devtools/src/config.ts", "../../../../modules/store-devtools/src/utils.ts", "../../../../modules/store-devtools/src/zone-config.ts", "../../../../modules/store-devtools/src/devtools-dispatcher.ts", "../../../../modules/store-devtools/src/extension.ts", "../../../../modules/store-devtools/src/reducer.ts", "../../../../modules/store-devtools/src/devtools.ts", "../../../../modules/store-devtools/src/provide-store-devtools.ts", "../../../../modules/store-devtools/src/instrument.ts"],
  "sourcesContent": ["import { Action } from '@ngrx/store';\n\nexport const PERFORM_ACTION = 'PERFORM_ACTION';\nexport const REFRESH = 'REFRESH';\nexport const RESET = 'RESET';\nexport const ROLLBACK = 'ROLLBACK';\nexport const COMMIT = 'COMMIT';\nexport const SWEEP = 'SWEEP';\nexport const TOGGLE_ACTION = 'TOGGLE_ACTION';\nexport const SET_ACTIONS_ACTIVE = 'SET_ACTIONS_ACTIVE';\nexport const JUMP_TO_STATE = 'JUMP_TO_STATE';\nexport const JUMP_TO_ACTION = 'JUMP_TO_ACTION';\nexport const IMPORT_STATE = 'IMPORT_STATE';\nexport const LOCK_CHANGES = 'LOCK_CHANGES';\nexport const PAUSE_RECORDING = 'PAUSE_RECORDING';\n\nexport class PerformAction implements Action {\n  readonly type = PERFORM_ACTION;\n\n  constructor(public action: Action, public timestamp: number) {\n    if (typeof action.type === 'undefined') {\n      throw new Error(\n        'Actions may not have an undefined \"type\" property. ' +\n          'Have you misspelled a constant?'\n      );\n    }\n  }\n}\n\nexport class Refresh implements Action {\n  readonly type = REFRESH;\n}\n\nexport class Reset implements Action {\n  readonly type = RESET;\n\n  constructor(public timestamp: number) {}\n}\n\nexport class Rollback implements Action {\n  readonly type = ROLLBACK;\n\n  constructor(public timestamp: number) {}\n}\n\nexport class Commit implements Action {\n  readonly type = COMMIT;\n\n  constructor(public timestamp: number) {}\n}\n\nexport class Sweep implements Action {\n  readonly type = SWEEP;\n}\n\nexport class ToggleAction implements Action {\n  readonly type = TOGGLE_ACTION;\n\n  constructor(public id: number) {}\n}\n\nexport class SetActionsActive implements Action {\n  readonly type = SET_ACTIONS_ACTIVE;\n\n  constructor(public start: number, public end: number, public active = true) {}\n}\n\nexport class JumpToState implements Action {\n  readonly type = JUMP_TO_STATE;\n\n  constructor(public index: number) {}\n}\n\nexport class JumpToAction implements Action {\n  readonly type = JUMP_TO_ACTION;\n\n  constructor(public actionId: number) {}\n}\n\nexport class ImportState implements Action {\n  readonly type = IMPORT_STATE;\n\n  constructor(public nextLiftedState: any) {}\n}\n\nexport class LockChanges implements Action {\n  readonly type = LOCK_CHANGES;\n\n  constructor(public status: boolean) {}\n}\n\nexport class PauseRecording implements Action {\n  readonly type = PAUSE_RECORDING;\n\n  constructor(public status: boolean) {}\n}\n\nexport type All =\n  | PerformAction\n  | Refresh\n  | Reset\n  | Rollback\n  | Commit\n  | Sweep\n  | ToggleAction\n  | SetActionsActive\n  | JumpToState\n  | JumpToAction\n  | ImportState\n  | LockChanges\n  | PauseRecording;\n", "import { ActionReducer, Action } from '@ngrx/store';\nimport { InjectionToken } from '@angular/core';\n\nexport type ActionSanitizer = (action: Action, id: number) => Action;\nexport type StateSanitizer = (state: any, index: number) => any;\nexport type SerializationOptions = {\n  options?: boolean | any;\n  replacer?: (key: any, value: any) => {};\n  reviver?: (key: any, value: any) => {};\n  immutable?: any;\n  refs?: Array<any>;\n};\nexport type Predicate = (state: any, action: Action) => boolean;\n\n/**\n * Chrome extension documentation\n * @see https://github.com/reduxjs/redux-devtools/blob/main/extension/docs/API/Arguments.md#features\n * Firefox extension documentation\n * @see https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Arguments.md#features\n */\nexport interface DevToolsFeatureOptions {\n  /**\n   * Start/pause recording of dispatched actions\n   */\n  pause?: boolean;\n  /**\n   * Lock/unlock dispatching actions and side effects\n   */\n  lock?: boolean;\n  /**\n   * Persist states on page reloading\n   */\n  persist?: boolean;\n  /**\n   * Export history of actions in a file\n   */\n  export?: boolean;\n  /**\n   * Import history of actions from a file\n   */\n  import?: 'custom' | boolean;\n  /**\n   * Jump back and forth (time travelling)\n   */\n  jump?: boolean;\n  /**\n   * Skip (cancel) actions\n   */\n  skip?: boolean;\n  /**\n   * Drag and drop actions in the history list\n   */\n  reorder?: boolean;\n  /**\n   * Dispatch custom actions or action creators\n   */\n  dispatch?: boolean;\n  /**\n   * Generate tests for the selected actions\n   */\n  test?: boolean;\n}\n\n/**\n * Chrome extension documentation\n * @see https://github.com/reduxjs/redux-devtools/blob/main/extension/docs/API/Arguments.md\n * Firefox extension documentation\n * @see https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Arguments.md\n */\nexport class StoreDevtoolsConfig {\n  /**\n   * Maximum allowed actions to be stored in the history tree (default: `false`)\n   */\n  maxAge: number | false = false;\n  monitor?: ActionReducer<any, any>;\n  /**\n   * Function which takes `action` object and id number as arguments, and should return `action` object back.\n   */\n  actionSanitizer?: ActionSanitizer;\n  /**\n   * Function which takes `state` object and index as arguments, and should return `state` object back.\n   */\n  stateSanitizer?: StateSanitizer;\n  /**\n   * The instance name to be shown on the monitor page (default: `document.title`)\n   */\n  name?: string;\n  serialize?: boolean | SerializationOptions;\n  logOnly?: boolean;\n  features?: DevToolsFeatureOptions;\n  /**\n   * Action types to be hidden in the monitors. If `actionsSafelist` specified, `actionsBlocklist` is ignored.\n   */\n  actionsBlocklist?: string[];\n  /**\n   * Action types to be shown in the monitors\n   */\n  actionsSafelist?: string[];\n  /**\n   * Called for every action before sending, takes state and action object, and returns true in case it allows sending the current data to the monitor.\n   */\n  predicate?: Predicate;\n  /**\n   * Auto pauses when the extensionâ€™s window is not opened, and so has zero impact on your app when not in use.\n   */\n  autoPause?: boolean;\n\n  /**\n   * If set to true, will include stack trace for every dispatched action\n   */\n  trace?: boolean | (() => string);\n\n  /**\n   * Maximum stack trace frames to be stored (in case trace option was provided as true).\n   */\n  traceLimit?: number;\n\n  /**\n   * The property determines whether the extension connection is established within the\n   * Angular zone or not. It is set to `false` by default.\n   */\n  connectInZone?: boolean;\n}\n\nexport const STORE_DEVTOOLS_CONFIG = new InjectionToken<StoreDevtoolsConfig>(\n  '@ngrx/store-devtools Options'\n);\n\n/**\n * Used to provide a `StoreDevtoolsConfig` for the store-devtools.\n */\nexport const INITIAL_OPTIONS = new InjectionToken<StoreDevtoolsConfig>(\n  '@ngrx/store-devtools Initial Config'\n);\n\nexport type StoreDevtoolsOptions =\n  | Partial<StoreDevtoolsConfig>\n  | (() => Partial<StoreDevtoolsConfig>);\n\nexport function noMonitor(): null {\n  return null;\n}\n\nexport const DEFAULT_NAME = 'NgRx Store DevTools';\n\nexport function createConfig(\n  optionsInput: StoreDevtoolsOptions\n): StoreDevtoolsConfig {\n  const DEFAULT_OPTIONS: StoreDevtoolsConfig = {\n    maxAge: false,\n    monitor: noMonitor,\n    actionSanitizer: undefined,\n    stateSanitizer: undefined,\n    name: DEFAULT_NAME,\n    serialize: false,\n    logOnly: false,\n    autoPause: false,\n    trace: false,\n    traceLimit: 75,\n    // Add all features explicitly. This prevent buggy behavior for\n    // options like \"lock\" which might otherwise not show up.\n    features: {\n      pause: true, // Start/pause recording of dispatched actions\n      lock: true, // Lock/unlock dispatching actions and side effects\n      persist: true, // Persist states on page reloading\n      export: true, // Export history of actions in a file\n      import: 'custom', // Import history of actions from a file\n      jump: true, // Jump back and forth (time travelling)\n      skip: true, // Skip (cancel) actions\n      reorder: true, // Drag and drop actions in the history list\n      dispatch: true, // Dispatch custom actions or action creators\n      test: true, // Generate tests for the selected actions\n    },\n    connectInZone: false,\n  };\n\n  const options =\n    typeof optionsInput === 'function' ? optionsInput() : optionsInput;\n  const logOnly = options.logOnly\n    ? { pause: true, export: true, test: true }\n    : false;\n  const features: NonNullable<Partial<StoreDevtoolsConfig['features']>> =\n    options.features ||\n    logOnly ||\n    (DEFAULT_OPTIONS.features as NonNullable<\n      Partial<StoreDevtoolsConfig['features']>\n    >);\n  if (features.import === true) {\n    features.import = 'custom';\n  }\n  const config = Object.assign({}, DEFAULT_OPTIONS, { features }, options);\n\n  if (config.maxAge && config.maxAge < 2) {\n    throw new Error(\n      `Devtools 'maxAge' cannot be less than 2, got ${config.maxAge}`\n    );\n  }\n\n  return config;\n}\n", "import { Action } from '@ngrx/store';\n\nimport * as Actions from './actions';\nimport {\n  ActionSanitizer,\n  StateSanitizer,\n  Predicate,\n  StoreDevtoolsConfig,\n} from './config';\nimport {\n  ComputedState,\n  LiftedAction,\n  LiftedActions,\n  LiftedState,\n} from './reducer';\n\nexport function difference(first: any[], second: any[]) {\n  return first.filter((item) => second.indexOf(item) < 0);\n}\n\n/**\n * Provides an app's view into the state of the lifted store.\n */\nexport function unliftState(liftedState: LiftedState) {\n  const { computedStates, currentStateIndex } = liftedState;\n\n  // At start up NgRx dispatches init actions,\n  // When these init actions are being filtered out by the predicate or safe/block list options\n  // we don't have a complete computed states yet.\n  // At this point it could happen that we're out of bounds, when this happens we fall back to the last known state\n  if (currentStateIndex >= computedStates.length) {\n    const { state } = computedStates[computedStates.length - 1];\n    return state;\n  }\n\n  const { state } = computedStates[currentStateIndex];\n  return state;\n}\n\nexport function unliftAction(liftedState: LiftedState): LiftedAction {\n  return liftedState.actionsById[liftedState.nextActionId - 1];\n}\n\n/**\n * Lifts an app's action into an action on the lifted store.\n */\nexport function liftAction(action: Action) {\n  return new Actions.PerformAction(action, +Date.now());\n}\n\n/**\n * Sanitizes given actions with given function.\n */\nexport function sanitizeActions(\n  actionSanitizer: ActionSanitizer,\n  actions: LiftedActions\n): LiftedActions {\n  return Object.keys(actions).reduce((sanitizedActions, actionIdx) => {\n    const idx = Number(actionIdx);\n    sanitizedActions[idx] = sanitizeAction(actionSanitizer, actions[idx], idx);\n    return sanitizedActions;\n  }, <LiftedActions>{});\n}\n\n/**\n * Sanitizes given action with given function.\n */\nexport function sanitizeAction(\n  actionSanitizer: ActionSanitizer,\n  action: LiftedAction,\n  actionIdx: number\n): LiftedAction {\n  return {\n    ...action,\n    action: actionSanitizer(action.action, actionIdx),\n  };\n}\n\n/**\n * Sanitizes given states with given function.\n */\nexport function sanitizeStates(\n  stateSanitizer: StateSanitizer,\n  states: ComputedState[]\n): ComputedState[] {\n  return states.map((computedState, idx) => ({\n    state: sanitizeState(stateSanitizer, computedState.state, idx),\n    error: computedState.error,\n  }));\n}\n\n/**\n * Sanitizes given state with given function.\n */\nexport function sanitizeState(\n  stateSanitizer: StateSanitizer,\n  state: any,\n  stateIdx: number\n) {\n  return stateSanitizer(state, stateIdx);\n}\n\n/**\n * Read the config and tell if actions should be filtered\n */\nexport function shouldFilterActions(config: StoreDevtoolsConfig) {\n  return config.predicate || config.actionsSafelist || config.actionsBlocklist;\n}\n\n/**\n * Return a full filtered lifted state\n */\nexport function filterLiftedState(\n  liftedState: LiftedState,\n  predicate?: Predicate,\n  safelist?: string[],\n  blocklist?: string[]\n): LiftedState {\n  const filteredStagedActionIds: number[] = [];\n  const filteredActionsById: LiftedActions = {};\n  const filteredComputedStates: ComputedState[] = [];\n  liftedState.stagedActionIds.forEach((id, idx) => {\n    const liftedAction = liftedState.actionsById[id];\n    if (!liftedAction) return;\n    if (\n      idx &&\n      isActionFiltered(\n        liftedState.computedStates[idx],\n        liftedAction,\n        predicate,\n        safelist,\n        blocklist\n      )\n    ) {\n      return;\n    }\n    filteredActionsById[id] = liftedAction;\n    filteredStagedActionIds.push(id);\n    filteredComputedStates.push(liftedState.computedStates[idx]);\n  });\n  return {\n    ...liftedState,\n    stagedActionIds: filteredStagedActionIds,\n    actionsById: filteredActionsById,\n    computedStates: filteredComputedStates,\n  };\n}\n\n/**\n * Return true is the action should be ignored\n */\nexport function isActionFiltered(\n  state: any,\n  action: LiftedAction,\n  predicate?: Predicate,\n  safelist?: string[],\n  blockedlist?: string[]\n) {\n  const predicateMatch = predicate && !predicate(state, action.action);\n  const safelistMatch =\n    safelist &&\n    !action.action.type.match(safelist.map((s) => escapeRegExp(s)).join('|'));\n  const blocklistMatch =\n    blockedlist &&\n    action.action.type.match(blockedlist.map((s) => escapeRegExp(s)).join('|'));\n  return predicateMatch || safelistMatch || blocklistMatch;\n}\n\n/**\n * Return string with escaped RegExp special characters\n * https://stackoverflow.com/a/6969486/1337347\n */\nfunction escapeRegExp(s: string): string {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n", "import { NgZone, inject } from '@angular/core';\n\nexport type ZoneConfig =\n  | { connectInZone: true; ngZone: NgZone }\n  | { connectInZone: false; ngZone: null };\n\nexport function injectZoneConfig(connectInZone: boolean) {\n  const ngZone = connectInZone ? inject(NgZone) : null;\n  return { ngZone, connectInZone } as ZoneConfig;\n}\n", "import { ActionsSubject } from '@ngrx/store';\nimport { Injectable } from '@angular/core';\n\n@Injectable()\nexport class DevtoolsDispatcher extends ActionsSubject {}\n", "import { Inject, Injectable, InjectionToken } from '@angular/core';\nimport { Action, UPDATE } from '@ngrx/store';\nimport { EMPTY, Observable, of } from 'rxjs';\nimport {\n  catchError,\n  concatMap,\n  debounceTime,\n  filter,\n  map,\n  share,\n  switchMap,\n  take,\n  takeUntil,\n  timeout,\n} from 'rxjs/operators';\n\nimport { IMPORT_STATE, PERFORM_ACTION } from './actions';\nimport {\n  SerializationOptions,\n  STORE_DEVTOOLS_CONFIG,\n  StoreDevtoolsConfig,\n} from './config';\nimport { DevtoolsDispatcher } from './devtools-dispatcher';\nimport { LiftedAction, LiftedState } from './reducer';\nimport {\n  isActionFiltered,\n  sanitizeAction,\n  sanitizeActions,\n  sanitizeState,\n  sanitizeStates,\n  shouldFilterActions,\n  unliftState,\n} from './utils';\nimport { injectZoneConfig } from './zone-config';\n\nexport const ExtensionActionTypes = {\n  START: 'START',\n  DISPATCH: 'DISPATCH',\n  STOP: 'STOP',\n  ACTION: 'ACTION',\n};\n\nexport const REDUX_DEVTOOLS_EXTENSION =\n  new InjectionToken<ReduxDevtoolsExtension>(\n    '@ngrx/store-devtools Redux Devtools Extension'\n  );\n\nexport interface ReduxDevtoolsExtensionConnection {\n  subscribe(listener: (change: any) => void): void;\n  unsubscribe(): void;\n  send(action: any, state: any): void;\n  init(state?: any): void;\n  error(anyErr: any): void;\n}\nexport interface ReduxDevtoolsExtensionConfig {\n  features?: object | boolean;\n  name: string | undefined;\n  maxAge?: number;\n  autoPause?: boolean;\n  serialize?: boolean | SerializationOptions;\n  trace?: boolean | (() => string);\n  traceLimit?: number;\n}\n\nexport interface ReduxDevtoolsExtension {\n  connect(\n    options: ReduxDevtoolsExtensionConfig\n  ): ReduxDevtoolsExtensionConnection;\n  send(action: any, state: any, options: ReduxDevtoolsExtensionConfig): void;\n}\n\n@Injectable()\nexport class DevtoolsExtension {\n  private devtoolsExtension: ReduxDevtoolsExtension;\n  private extensionConnection!: ReduxDevtoolsExtensionConnection;\n\n  liftedActions$!: Observable<any>;\n  actions$!: Observable<any>;\n  start$!: Observable<any>;\n\n  private zoneConfig = injectZoneConfig(this.config.connectInZone!);\n\n  constructor(\n    @Inject(REDUX_DEVTOOLS_EXTENSION) devtoolsExtension: ReduxDevtoolsExtension,\n    @Inject(STORE_DEVTOOLS_CONFIG) private config: StoreDevtoolsConfig,\n    private dispatcher: DevtoolsDispatcher\n  ) {\n    this.devtoolsExtension = devtoolsExtension;\n    this.createActionStreams();\n  }\n\n  notify(action: LiftedAction, state: LiftedState) {\n    if (!this.devtoolsExtension) {\n      return;\n    }\n    // Check to see if the action requires a full update of the liftedState.\n    // If it is a simple action generated by the user's app and the recording\n    // is not locked/paused, only send the action and the current state (fast).\n    //\n    // A full liftedState update (slow: serializes the entire liftedState) is\n    // only required when:\n    //   a) redux-devtools-extension fires the @@Init action (ignored by\n    //      @ngrx/store-devtools)\n    //   b) an action is generated by an @ngrx module (e.g. @ngrx/effects/init\n    //      or @ngrx/store/update-reducers)\n    //   c) the state has been recomputed due to time-traveling\n    //   d) any action that is not a PerformAction to err on the side of\n    //      caution.\n    if (action.type === PERFORM_ACTION) {\n      if (state.isLocked || state.isPaused) {\n        return;\n      }\n\n      const currentState = unliftState(state);\n      if (\n        shouldFilterActions(this.config) &&\n        isActionFiltered(\n          currentState,\n          action,\n          this.config.predicate,\n          this.config.actionsSafelist,\n          this.config.actionsBlocklist\n        )\n      ) {\n        return;\n      }\n      const sanitizedState = this.config.stateSanitizer\n        ? sanitizeState(\n            this.config.stateSanitizer,\n            currentState,\n            state.currentStateIndex\n          )\n        : currentState;\n      const sanitizedAction = this.config.actionSanitizer\n        ? sanitizeAction(\n            this.config.actionSanitizer,\n            action,\n            state.nextActionId\n          )\n        : action;\n\n      this.sendToReduxDevtools(() =>\n        this.extensionConnection.send(sanitizedAction, sanitizedState)\n      );\n    } else {\n      // Requires full state update\n      const sanitizedLiftedState = {\n        ...state,\n        stagedActionIds: state.stagedActionIds,\n        actionsById: this.config.actionSanitizer\n          ? sanitizeActions(this.config.actionSanitizer, state.actionsById)\n          : state.actionsById,\n        computedStates: this.config.stateSanitizer\n          ? sanitizeStates(this.config.stateSanitizer, state.computedStates)\n          : state.computedStates,\n      };\n\n      this.sendToReduxDevtools(() =>\n        this.devtoolsExtension.send(\n          null,\n          sanitizedLiftedState,\n          this.getExtensionConfig(this.config)\n        )\n      );\n    }\n  }\n\n  private createChangesObservable(): Observable<any> {\n    if (!this.devtoolsExtension) {\n      return EMPTY;\n    }\n\n    return new Observable((subscriber) => {\n      const connection = this.zoneConfig.connectInZone\n        ? // To reduce change detection cycles, we need to run the `connect` method\n          // outside of the Angular zone. The `connect` method adds a `message`\n          // event listener to communicate with an extension using `window.postMessage`\n          // and handle message events.\n          this.zoneConfig.ngZone.runOutsideAngular(() =>\n            this.devtoolsExtension.connect(this.getExtensionConfig(this.config))\n          )\n        : this.devtoolsExtension.connect(this.getExtensionConfig(this.config));\n\n      this.extensionConnection = connection;\n      connection.init();\n\n      connection.subscribe((change: any) => subscriber.next(change));\n      return connection.unsubscribe;\n    });\n  }\n\n  private createActionStreams() {\n    // Listens to all changes\n    const changes$ = this.createChangesObservable().pipe(share());\n\n    // Listen for the start action\n    const start$ = changes$.pipe(\n      filter((change: any) => change.type === ExtensionActionTypes.START)\n    );\n\n    // Listen for the stop action\n    const stop$ = changes$.pipe(\n      filter((change: any) => change.type === ExtensionActionTypes.STOP)\n    );\n\n    // Listen for lifted actions\n    const liftedActions$ = changes$.pipe(\n      filter((change) => change.type === ExtensionActionTypes.DISPATCH),\n      map((change) => this.unwrapAction(change.payload)),\n      concatMap((action: any) => {\n        if (action.type === IMPORT_STATE) {\n          // State imports may happen in two situations:\n          // 1. Explicitly by user\n          // 2. User activated the \"persist state accross reloads\" option\n          //    and now the state is imported during reload.\n          // Because of option 2, we need to give possible\n          // lazy loaded reducers time to instantiate.\n          // As soon as there is no UPDATE action within 1 second,\n          // it is assumed that all reducers are loaded.\n          return this.dispatcher.pipe(\n            filter((action) => action.type === UPDATE),\n            timeout(1000),\n            debounceTime(1000),\n            map(() => action),\n            catchError(() => of(action)),\n            take(1)\n          );\n        } else {\n          return of(action);\n        }\n      })\n    );\n\n    // Listen for unlifted actions\n    const actions$ = changes$.pipe(\n      filter((change) => change.type === ExtensionActionTypes.ACTION),\n      map((change) => this.unwrapAction(change.payload))\n    );\n\n    const actionsUntilStop$ = actions$.pipe(takeUntil(stop$));\n    const liftedUntilStop$ = liftedActions$.pipe(takeUntil(stop$));\n    this.start$ = start$.pipe(takeUntil(stop$));\n\n    // Only take the action sources between the start/stop events\n    this.actions$ = this.start$.pipe(switchMap(() => actionsUntilStop$));\n    this.liftedActions$ = this.start$.pipe(switchMap(() => liftedUntilStop$));\n  }\n\n  private unwrapAction(action: Action) {\n    // indirect eval according to https://esbuild.github.io/content-types/#direct-eval\n    return typeof action === 'string' ? (0, eval)(`(${action})`) : action;\n  }\n\n  private getExtensionConfig(config: StoreDevtoolsConfig) {\n    const extensionOptions: ReduxDevtoolsExtensionConfig = {\n      name: config.name,\n      features: config.features,\n      serialize: config.serialize,\n      autoPause: config.autoPause ?? false,\n      trace: config.trace ?? false,\n      traceLimit: config.traceLimit ?? 75,\n      // The action/state sanitizers are not added to the config\n      // because sanitation is done in this class already.\n      // It is done before sending it to the devtools extension for consistency:\n      // - If we call extensionConnection.send(...),\n      //   the extension would call the sanitizers.\n      // - If we call devtoolsExtension.send(...) (aka full state update),\n      //   the extension would NOT call the sanitizers, so we have to do it ourselves.\n    };\n    if (config.maxAge !== false /* support === 0 */) {\n      extensionOptions.maxAge = config.maxAge;\n    }\n    return extensionOptions;\n  }\n\n  private sendToReduxDevtools(send: Function) {\n    try {\n      send();\n    } catch (err: any) {\n      console.warn(\n        '@ngrx/store-devtools: something went wrong inside the redux devtools',\n        err\n      );\n    }\n  }\n}\n", "import { ErrorHandler } from '@angular/core';\nimport { Action, ActionReducer, UPDATE, INIT } from '@ngrx/store';\n\nimport { difference, liftAction, isActionFiltered } from './utils';\nimport * as DevtoolsActions from './actions';\nimport { StoreDevtoolsConfig } from './config';\nimport { PerformAction } from './actions';\n\nexport type InitAction = {\n  readonly type: typeof INIT;\n};\n\nexport type UpdateReducerAction = {\n  readonly type: typeof UPDATE;\n};\n\nexport type CoreActions = InitAction | UpdateReducerAction;\nexport type Actions = DevtoolsActions.All | CoreActions;\n\nexport const INIT_ACTION = { type: INIT };\n\nexport const RECOMPUTE = '@ngrx/store-devtools/recompute' as const;\nexport const RECOMPUTE_ACTION = { type: RECOMPUTE };\n\nexport interface ComputedState {\n  state: any;\n  error: any;\n}\n\nexport interface LiftedAction {\n  type: string;\n  action: Action;\n}\n\nexport interface LiftedActions {\n  [id: number]: LiftedAction;\n}\n\nexport interface LiftedState {\n  monitorState: any;\n  nextActionId: number;\n  actionsById: LiftedActions;\n  stagedActionIds: number[];\n  skippedActionIds: number[];\n  committedState: any;\n  currentStateIndex: number;\n  computedStates: ComputedState[];\n  isLocked: boolean;\n  isPaused: boolean;\n}\n\n/**\n * Computes the next entry in the log by applying an action.\n */\nfunction computeNextEntry(\n  reducer: ActionReducer<any, any>,\n  action: Action,\n  state: any,\n  error: any,\n  errorHandler: ErrorHandler\n) {\n  if (error) {\n    return {\n      state,\n      error: 'Interrupted by an error up the chain',\n    };\n  }\n\n  let nextState = state;\n  let nextError;\n  try {\n    nextState = reducer(state, action);\n  } catch (err: any) {\n    nextError = err.toString();\n    errorHandler.handleError(err);\n  }\n\n  return {\n    state: nextState,\n    error: nextError,\n  };\n}\n\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\nfunction recomputeStates(\n  computedStates: ComputedState[],\n  minInvalidatedStateIndex: number,\n  reducer: ActionReducer<any, any>,\n  committedState: any,\n  actionsById: LiftedActions,\n  stagedActionIds: number[],\n  skippedActionIds: number[],\n  errorHandler: ErrorHandler,\n  isPaused: boolean\n) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (\n    minInvalidatedStateIndex >= computedStates.length &&\n    computedStates.length === stagedActionIds.length\n  ) {\n    return computedStates;\n  }\n\n  const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n  // If the recording is paused, recompute all states up until the pause state,\n  // else recompute all states.\n  const lastIncludedActionId = stagedActionIds.length - (isPaused ? 1 : 0);\n  for (let i = minInvalidatedStateIndex; i < lastIncludedActionId; i++) {\n    const actionId = stagedActionIds[i];\n    const action = actionsById[actionId].action;\n\n    const previousEntry = nextComputedStates[i - 1];\n    const previousState = previousEntry ? previousEntry.state : committedState;\n    const previousError = previousEntry ? previousEntry.error : undefined;\n\n    const shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    const entry: ComputedState = shouldSkip\n      ? previousEntry\n      : computeNextEntry(\n          reducer,\n          action,\n          previousState,\n          previousError,\n          errorHandler\n        );\n\n    nextComputedStates.push(entry);\n  }\n  // If the recording is paused, the last state will not be recomputed,\n  // because it's essentially not part of the state history.\n  if (isPaused) {\n    nextComputedStates.push(computedStates[computedStates.length - 1]);\n  }\n\n  return nextComputedStates;\n}\n\nexport function liftInitialState(\n  initialCommittedState?: any,\n  monitorReducer?: any\n): LiftedState {\n  return {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: { 0: liftAction(INIT_ACTION) },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: false,\n    isPaused: false,\n  };\n}\n\n/**\n * Creates a history state reducer from an app's reducer.\n */\nexport function liftReducerWith(\n  initialCommittedState: any,\n  initialLiftedState: LiftedState,\n  errorHandler: ErrorHandler,\n  monitorReducer?: any,\n  options: Partial<StoreDevtoolsConfig> = {}\n) {\n  /**\n   * Manages how the history actions modify the history state.\n   */\n  return (\n      reducer: ActionReducer<any, any>\n    ): ActionReducer<LiftedState, Actions> =>\n    (liftedState, liftedAction) => {\n      let {\n        monitorState,\n        actionsById,\n        nextActionId,\n        stagedActionIds,\n        skippedActionIds,\n        committedState,\n        currentStateIndex,\n        computedStates,\n        isLocked,\n        isPaused,\n      } = liftedState || initialLiftedState;\n\n      if (!liftedState) {\n        // Prevent mutating initialLiftedState\n        actionsById = Object.create(actionsById);\n      }\n\n      function commitExcessActions(n: number) {\n        // Auto-commits n-number of excess actions.\n        let excess = n;\n        let idsToDelete = stagedActionIds.slice(1, excess + 1);\n\n        for (let i = 0; i < idsToDelete.length; i++) {\n          if (computedStates[i + 1].error) {\n            // Stop if error is found. Commit actions up to error.\n            excess = i;\n            idsToDelete = stagedActionIds.slice(1, excess + 1);\n            break;\n          } else {\n            delete actionsById[idsToDelete[i]];\n          }\n        }\n\n        skippedActionIds = skippedActionIds.filter(\n          (id) => idsToDelete.indexOf(id) === -1\n        );\n        stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];\n        committedState = computedStates[excess].state;\n        computedStates = computedStates.slice(excess);\n        currentStateIndex =\n          currentStateIndex > excess ? currentStateIndex - excess : 0;\n      }\n\n      function commitChanges() {\n        // Consider the last committed state the new starting point.\n        // Squash any staged actions into a single committed state.\n        actionsById = { 0: liftAction(INIT_ACTION) };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = computedStates[currentStateIndex].state;\n        currentStateIndex = 0;\n        computedStates = [];\n      }\n\n      // By default, aggressively recompute every state whatever happens.\n      // This has O(n) performance, so we'll override this to a sensible\n      // value whenever we feel like we don't have to recompute the states.\n      let minInvalidatedStateIndex = 0;\n\n      switch (liftedAction.type) {\n        case DevtoolsActions.LOCK_CHANGES: {\n          isLocked = liftedAction.status;\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n        case DevtoolsActions.PAUSE_RECORDING: {\n          isPaused = liftedAction.status;\n          if (isPaused) {\n            // Add a pause action to signal the devtools-user the recording is paused.\n            // The corresponding state will be overwritten on each update to always contain\n            // the latest state (see Actions.PERFORM_ACTION).\n            stagedActionIds = [...stagedActionIds, nextActionId];\n            actionsById[nextActionId] = new PerformAction(\n              {\n                type: '@ngrx/devtools/pause',\n              },\n              +Date.now()\n            );\n            nextActionId++;\n            minInvalidatedStateIndex = stagedActionIds.length - 1;\n            computedStates = computedStates.concat(\n              computedStates[computedStates.length - 1]\n            );\n\n            if (currentStateIndex === stagedActionIds.length - 2) {\n              currentStateIndex++;\n            }\n            minInvalidatedStateIndex = Infinity;\n          } else {\n            commitChanges();\n          }\n          break;\n        }\n        case DevtoolsActions.RESET: {\n          // Get back to the state the store was created with.\n          actionsById = { 0: liftAction(INIT_ACTION) };\n          nextActionId = 1;\n          stagedActionIds = [0];\n          skippedActionIds = [];\n          committedState = initialCommittedState;\n          currentStateIndex = 0;\n          computedStates = [];\n          break;\n        }\n        case DevtoolsActions.COMMIT: {\n          commitChanges();\n          break;\n        }\n        case DevtoolsActions.ROLLBACK: {\n          // Forget about any staged actions.\n          // Start again from the last committed state.\n          actionsById = { 0: liftAction(INIT_ACTION) };\n          nextActionId = 1;\n          stagedActionIds = [0];\n          skippedActionIds = [];\n          currentStateIndex = 0;\n          computedStates = [];\n          break;\n        }\n        case DevtoolsActions.TOGGLE_ACTION: {\n          // Toggle whether an action with given ID is skipped.\n          // Being skipped means it is a no-op during the computation.\n          const { id: actionId } = liftedAction;\n          const index = skippedActionIds.indexOf(actionId);\n          if (index === -1) {\n            skippedActionIds = [actionId, ...skippedActionIds];\n          } else {\n            skippedActionIds = skippedActionIds.filter((id) => id !== actionId);\n          }\n          // Optimization: we know history before this action hasn't changed\n          minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n          break;\n        }\n        case DevtoolsActions.SET_ACTIONS_ACTIVE: {\n          // Toggle whether an action with given ID is skipped.\n          // Being skipped means it is a no-op during the computation.\n          const { start, end, active } = liftedAction;\n          const actionIds = [];\n          for (let i = start; i < end; i++) actionIds.push(i);\n          if (active) {\n            skippedActionIds = difference(skippedActionIds, actionIds);\n          } else {\n            skippedActionIds = [...skippedActionIds, ...actionIds];\n          }\n\n          // Optimization: we know history before this action hasn't changed\n          minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n          break;\n        }\n        case DevtoolsActions.JUMP_TO_STATE: {\n          // Without recomputing anything, move the pointer that tell us\n          // which state is considered the current one. Useful for sliders.\n          currentStateIndex = liftedAction.index;\n          // Optimization: we know the history has not changed.\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n        case DevtoolsActions.JUMP_TO_ACTION: {\n          // Jumps to a corresponding state to a specific action.\n          // Useful when filtering actions.\n          const index = stagedActionIds.indexOf(liftedAction.actionId);\n          if (index !== -1) currentStateIndex = index;\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n        case DevtoolsActions.SWEEP: {\n          // Forget any actions that are currently being skipped.\n          stagedActionIds = difference(stagedActionIds, skippedActionIds);\n          skippedActionIds = [];\n          currentStateIndex = Math.min(\n            currentStateIndex,\n            stagedActionIds.length - 1\n          );\n          break;\n        }\n        case DevtoolsActions.PERFORM_ACTION: {\n          // Ignore action and return state as is if recording is locked\n          if (isLocked) {\n            return liftedState || initialLiftedState;\n          }\n\n          if (\n            isPaused ||\n            (liftedState &&\n              isActionFiltered(\n                liftedState.computedStates[currentStateIndex],\n                liftedAction,\n                options.predicate,\n                options.actionsSafelist,\n                options.actionsBlocklist\n              ))\n          ) {\n            // If recording is paused or if the action should be ignored, overwrite the last state\n            // (corresponds to the pause action) and keep everything else as is.\n            // This way, the app gets the new current state while the devtools\n            // do not record another action.\n            const lastState = computedStates[computedStates.length - 1];\n            computedStates = [\n              ...computedStates.slice(0, -1),\n              computeNextEntry(\n                reducer,\n                liftedAction.action,\n                lastState.state,\n                lastState.error,\n                errorHandler\n              ),\n            ];\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n          // Auto-commit as new actions come in.\n          if (options.maxAge && stagedActionIds.length === options.maxAge) {\n            commitExcessActions(1);\n          }\n\n          if (currentStateIndex === stagedActionIds.length - 1) {\n            currentStateIndex++;\n          }\n          const actionId = nextActionId++;\n          // Mutation! This is the hottest path, and we optimize on purpose.\n          // It is safe because we set a new key in a cache dictionary.\n          actionsById[actionId] = liftedAction;\n\n          stagedActionIds = [...stagedActionIds, actionId];\n          // Optimization: we know that only the new action needs computing.\n          minInvalidatedStateIndex = stagedActionIds.length - 1;\n          break;\n        }\n        case DevtoolsActions.IMPORT_STATE: {\n          // Completely replace everything.\n          ({\n            monitorState,\n            actionsById,\n            nextActionId,\n            stagedActionIds,\n            skippedActionIds,\n            committedState,\n            currentStateIndex,\n            computedStates,\n            isLocked,\n            isPaused,\n          } = liftedAction.nextLiftedState);\n          break;\n        }\n        case INIT: {\n          // Always recompute states on hot reload and init.\n          minInvalidatedStateIndex = 0;\n\n          if (options.maxAge && stagedActionIds.length > options.maxAge) {\n            // States must be recomputed before committing excess.\n            computedStates = recomputeStates(\n              computedStates,\n              minInvalidatedStateIndex,\n              reducer,\n              committedState,\n              actionsById,\n              stagedActionIds,\n              skippedActionIds,\n              errorHandler,\n              isPaused\n            );\n\n            commitExcessActions(stagedActionIds.length - options.maxAge);\n\n            // Avoid double computation.\n            minInvalidatedStateIndex = Infinity;\n          }\n\n          break;\n        }\n        case UPDATE: {\n          const stateHasErrors =\n            computedStates.filter((state) => state.error).length > 0;\n\n          if (stateHasErrors) {\n            // Recompute all states\n            minInvalidatedStateIndex = 0;\n\n            if (options.maxAge && stagedActionIds.length > options.maxAge) {\n              // States must be recomputed before committing excess.\n              computedStates = recomputeStates(\n                computedStates,\n                minInvalidatedStateIndex,\n                reducer,\n                committedState,\n                actionsById,\n                stagedActionIds,\n                skippedActionIds,\n                errorHandler,\n                isPaused\n              );\n\n              commitExcessActions(stagedActionIds.length - options.maxAge);\n\n              // Avoid double computation.\n              minInvalidatedStateIndex = Infinity;\n            }\n          } else {\n            // If not paused/locked, add a new action to signal devtools-user\n            // that there was a reducer update.\n            if (!isPaused && !isLocked) {\n              if (currentStateIndex === stagedActionIds.length - 1) {\n                currentStateIndex++;\n              }\n\n              // Add a new action to only recompute state\n              const actionId = nextActionId++;\n              actionsById[actionId] = new PerformAction(\n                liftedAction,\n                +Date.now()\n              );\n              stagedActionIds = [...stagedActionIds, actionId];\n\n              minInvalidatedStateIndex = stagedActionIds.length - 1;\n\n              computedStates = recomputeStates(\n                computedStates,\n                minInvalidatedStateIndex,\n                reducer,\n                committedState,\n                actionsById,\n                stagedActionIds,\n                skippedActionIds,\n                errorHandler,\n                isPaused\n              );\n            }\n\n            // Recompute state history with latest reducer and update action\n            computedStates = computedStates.map((cmp) => ({\n              ...cmp,\n              state: reducer(cmp.state, RECOMPUTE_ACTION),\n            }));\n\n            currentStateIndex = stagedActionIds.length - 1;\n\n            if (options.maxAge && stagedActionIds.length > options.maxAge) {\n              commitExcessActions(stagedActionIds.length - options.maxAge);\n            }\n\n            // Avoid double computation.\n            minInvalidatedStateIndex = Infinity;\n          }\n\n          break;\n        }\n        default: {\n          // If the action is not recognized, it's a monitor action.\n          // Optimization: a monitor action can't change history.\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n      }\n\n      computedStates = recomputeStates(\n        computedStates,\n        minInvalidatedStateIndex,\n        reducer,\n        committedState,\n        actionsById,\n        stagedActionIds,\n        skippedActionIds,\n        errorHandler,\n        isPaused\n      );\n      monitorState = monitorReducer(monitorState, liftedAction);\n\n      return {\n        monitorState,\n        actionsById,\n        nextActionId,\n        stagedActionIds,\n        skippedActionIds,\n        committedState,\n        currentStateIndex,\n        computedStates,\n        isLocked,\n        isPaused,\n      };\n    };\n}\n", "import {\n  Injectable,\n  Inject,\n  ErrorHandler,\n  OnDestroy,\n  NgZone,\n  inject,\n} from '@angular/core';\nimport { toSignal } from '@angular/core/rxjs-interop';\nimport {\n  Action,\n  ActionReducer,\n  ActionsSubject,\n  INITIAL_STATE,\n  ReducerObservable,\n  ScannedActionsSubject,\n  StateObservable,\n} from '@ngrx/store';\nimport {\n  merge,\n  MonoTypeOperatorFunction,\n  Observable,\n  Observer,\n  queueScheduler,\n  ReplaySubject,\n  Subscription,\n} from 'rxjs';\nimport { map, observeOn, scan, skip, withLatestFrom } from 'rxjs/operators';\n\nimport * as Actions from './actions';\nimport { STORE_DEVTOOLS_CONFIG, StoreDevtoolsConfig } from './config';\nimport { DevtoolsExtension } from './extension';\nimport { LiftedState, liftInitialState, liftReducerWith } from './reducer';\nimport {\n  liftAction,\n  unliftState,\n  shouldFilterActions,\n  filterLiftedState,\n} from './utils';\nimport { DevtoolsDispatcher } from './devtools-dispatcher';\nimport { PERFORM_ACTION } from './actions';\nimport { ZoneConfig, injectZoneConfig } from './zone-config';\n\n@Injectable()\nexport class StoreDevtools implements Observer<any>, OnDestroy {\n  private liftedStateSubscription: Subscription;\n  private extensionStartSubscription: Subscription;\n  public dispatcher: ActionsSubject;\n  public liftedState: Observable<LiftedState>;\n  public state: StateObservable;\n\n  constructor(\n    dispatcher: DevtoolsDispatcher,\n    actions$: ActionsSubject,\n    reducers$: ReducerObservable,\n    extension: DevtoolsExtension,\n    scannedActions: ScannedActionsSubject,\n    errorHandler: ErrorHandler,\n    @Inject(INITIAL_STATE) initialState: any,\n    @Inject(STORE_DEVTOOLS_CONFIG) config: StoreDevtoolsConfig\n  ) {\n    const liftedInitialState = liftInitialState(initialState, config.monitor);\n    const liftReducer = liftReducerWith(\n      initialState,\n      liftedInitialState,\n      errorHandler,\n      config.monitor,\n      config\n    );\n\n    const liftedAction$ = merge(\n      merge(actions$.asObservable().pipe(skip(1)), extension.actions$).pipe(\n        map(liftAction)\n      ),\n      dispatcher,\n      extension.liftedActions$\n    ).pipe(observeOn(queueScheduler));\n\n    const liftedReducer$ = reducers$.pipe(map(liftReducer));\n\n    const zoneConfig = injectZoneConfig(config.connectInZone!);\n\n    const liftedStateSubject = new ReplaySubject<LiftedState>(1);\n\n    this.liftedStateSubscription = liftedAction$\n      .pipe(\n        withLatestFrom(liftedReducer$),\n        // The extension would post messages back outside of the Angular zone\n        // because we call `connect()` wrapped with `runOutsideAngular`. We run change\n        // detection only once at the end after all the required asynchronous tasks have\n        // been processed (for instance, `setInterval` scheduled by the `timeout` operator).\n        // We have to re-enter the Angular zone before the `scan` since it runs the reducer\n        // which must be run within the Angular zone.\n        emitInZone(zoneConfig),\n        scan<\n          [any, ActionReducer<LiftedState, Actions.All>],\n          {\n            state: LiftedState;\n            action: any;\n          }\n        >(\n          ({ state: liftedState }, [action, reducer]) => {\n            let reducedLiftedState = reducer(liftedState, action);\n            // On full state update\n            // If we have actions filters, we must filter completely our lifted state to be sync with the extension\n            if (action.type !== PERFORM_ACTION && shouldFilterActions(config)) {\n              reducedLiftedState = filterLiftedState(\n                reducedLiftedState,\n                config.predicate,\n                config.actionsSafelist,\n                config.actionsBlocklist\n              );\n            }\n            // Extension should be sent the sanitized lifted state\n            extension.notify(action, reducedLiftedState);\n            return { state: reducedLiftedState, action };\n          },\n          { state: liftedInitialState, action: null as any }\n        )\n      )\n      .subscribe(({ state, action }) => {\n        liftedStateSubject.next(state);\n\n        if (action.type === Actions.PERFORM_ACTION) {\n          const unliftedAction = (action as Actions.PerformAction).action;\n\n          scannedActions.next(unliftedAction);\n        }\n      });\n\n    this.extensionStartSubscription = extension.start$\n      .pipe(emitInZone(zoneConfig))\n      .subscribe(() => {\n        this.refresh();\n      });\n\n    const liftedState$ =\n      liftedStateSubject.asObservable() as Observable<LiftedState>;\n    const state$ = liftedState$.pipe(map(unliftState)) as StateObservable;\n    Object.defineProperty(state$, 'state', {\n      value: toSignal(state$, { manualCleanup: true, requireSync: true }),\n    });\n\n    this.dispatcher = dispatcher;\n    this.liftedState = liftedState$;\n    this.state = state$;\n  }\n\n  ngOnDestroy(): void {\n    // Even though the store devtools plugin is recommended to be\n    // used only in development mode, it can still cause a memory leak\n    // in microfrontend applications that are being created and destroyed\n    // multiple times during development. This results in excessive memory\n    // consumption, as it prevents entire apps from being garbage collected.\n    this.liftedStateSubscription.unsubscribe();\n    this.extensionStartSubscription.unsubscribe();\n  }\n\n  dispatch(action: Action) {\n    this.dispatcher.next(action);\n  }\n\n  next(action: any) {\n    this.dispatcher.next(action);\n  }\n\n  error(error: any) {}\n\n  complete() {}\n\n  performAction(action: any) {\n    this.dispatch(new Actions.PerformAction(action, +Date.now()));\n  }\n\n  refresh() {\n    this.dispatch(new Actions.Refresh());\n  }\n\n  reset() {\n    this.dispatch(new Actions.Reset(+Date.now()));\n  }\n\n  rollback() {\n    this.dispatch(new Actions.Rollback(+Date.now()));\n  }\n\n  commit() {\n    this.dispatch(new Actions.Commit(+Date.now()));\n  }\n\n  sweep() {\n    this.dispatch(new Actions.Sweep());\n  }\n\n  toggleAction(id: number) {\n    this.dispatch(new Actions.ToggleAction(id));\n  }\n\n  jumpToAction(actionId: number) {\n    this.dispatch(new Actions.JumpToAction(actionId));\n  }\n\n  jumpToState(index: number) {\n    this.dispatch(new Actions.JumpToState(index));\n  }\n\n  importState(nextLiftedState: any) {\n    this.dispatch(new Actions.ImportState(nextLiftedState));\n  }\n\n  lockChanges(status: boolean) {\n    this.dispatch(new Actions.LockChanges(status));\n  }\n\n  pauseRecording(status: boolean) {\n    this.dispatch(new Actions.PauseRecording(status));\n  }\n}\n\n/**\n * If the devtools extension is connected out of the Angular zone,\n * this operator will emit all events within the zone.\n */\nfunction emitInZone<T>({\n  ngZone,\n  connectInZone,\n}: ZoneConfig): MonoTypeOperatorFunction<T> {\n  return (source) =>\n    connectInZone\n      ? new Observable<T>((subscriber) =>\n          source.subscribe({\n            next: (value) => ngZone.run(() => subscriber.next(value)),\n            error: (error) => ngZone.run(() => subscriber.error(error)),\n            complete: () => ngZone.run(() => subscriber.complete()),\n          })\n        )\n      : source;\n}\n", "import {\n  EnvironmentProviders,\n  InjectionToken,\n  makeEnvironmentProviders,\n  Provider,\n} from '@angular/core';\nimport {\n  DevtoolsExtension,\n  REDUX_DEVTOOLS_EXTENSION,\n  ReduxDevtoolsExtension,\n} from './extension';\nimport { DevtoolsDispatcher } from './devtools-dispatcher';\nimport {\n  createConfig,\n  INITIAL_OPTIONS,\n  noMonitor,\n  STORE_DEVTOOLS_CONFIG,\n  StoreDevtoolsConfig,\n  StoreDevtoolsOptions,\n} from './config';\nimport { ReducerManagerDispatcher, StateObservable } from '@ngrx/store';\nimport { createStateObservable } from './instrument';\nimport { StoreDevtools } from './devtools';\n\nexport const IS_EXTENSION_OR_MONITOR_PRESENT = new InjectionToken<boolean>(\n  '@ngrx/store-devtools Is Devtools Extension or Monitor Present'\n);\n\nexport function createIsExtensionOrMonitorPresent(\n  extension: ReduxDevtoolsExtension | null,\n  config: StoreDevtoolsConfig\n) {\n  return Boolean(extension) || config.monitor !== noMonitor;\n}\n\nexport function createReduxDevtoolsExtension() {\n  const extensionKey = '__REDUX_DEVTOOLS_EXTENSION__';\n\n  if (\n    typeof window === 'object' &&\n    typeof (window as any)[extensionKey] !== 'undefined'\n  ) {\n    return (window as any)[extensionKey];\n  } else {\n    return null;\n  }\n}\n\n/**\n * Provides developer tools and instrumentation for `Store`.\n *\n * @usageNotes\n *\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [\n *     provideStoreDevtools({\n *       maxAge: 25,\n *       logOnly: !isDevMode(),\n *     }),\n *   ],\n * });\n * ```\n */\nexport function provideStoreDevtools(\n  options: StoreDevtoolsOptions = {}\n): EnvironmentProviders {\n  return makeEnvironmentProviders([\n    DevtoolsExtension,\n    DevtoolsDispatcher,\n    StoreDevtools,\n    {\n      provide: INITIAL_OPTIONS,\n      useValue: options,\n    },\n    {\n      provide: IS_EXTENSION_OR_MONITOR_PRESENT,\n      deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],\n      useFactory: createIsExtensionOrMonitorPresent,\n    },\n    {\n      provide: REDUX_DEVTOOLS_EXTENSION,\n      useFactory: createReduxDevtoolsExtension,\n    },\n    {\n      provide: STORE_DEVTOOLS_CONFIG,\n      deps: [INITIAL_OPTIONS],\n      useFactory: createConfig,\n    },\n    {\n      provide: StateObservable,\n      deps: [StoreDevtools],\n      useFactory: createStateObservable,\n    },\n    {\n      provide: ReducerManagerDispatcher,\n      useExisting: DevtoolsDispatcher,\n    },\n  ]);\n}\n", "import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { StateObservable } from '@ngrx/store';\nimport { StoreDevtoolsOptions } from './config';\nimport { StoreDevtools } from './devtools';\nimport { provideStoreDevtools } from './provide-store-devtools';\n\nexport function createStateObservable(\n  devtools: StoreDevtools\n): StateObservable {\n  return devtools.state;\n}\n\n@NgModule({})\nexport class StoreDevtoolsModule {\n  static instrument(\n    options: StoreDevtoolsOptions = {}\n  ): ModuleWithProviders<StoreDevtoolsModule> {\n    return {\n      ngModule: StoreDevtoolsModule,\n      providers: [provideStoreDevtools(options)],\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": ["state", "Injectable", "InjectionToken", "action", "UPDATE", "Injectable", "Inject", "Observable", "map", "InjectionToken"]
}
